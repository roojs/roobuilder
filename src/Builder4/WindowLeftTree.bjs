{
 "build_module" : "builder",
 "items" : [
  {
   "# Xcls_MainWindow main_window" : "null",
   "$ xns" : "Gtk",
   "@ bool before_node_change" : "()",
   "@ void changed" : "()",
   "@ void node_selected" : "(JsRender.Node? node, string source)",
   "Gtk.Orientation orientation" : "Gtk.Orientation.VERTICAL",
   "id" : "WindowLeftTree",
   "items" : [
    {
     "$ xns" : "Gtk",
     "* init" : [
      " this.el.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC);",
      " ",
      ""
     ],
     "bool has_frame" : true,
     "id" : "viewwin",
     "items" : [
      {
       "# bool blockChanges" : false,
       "# bool drag_in_motion" : "",
       "# int drag_x" : "",
       "# int drag_y" : "",
       "# string dragData" : "",
       "# string[] dropList" : "",
       "$ enable_tree_lines" : true,
       "$ string lastEventSource" : "\"\"",
       "$ xns" : "Gtk",
       "* init" : [
        "{",
        "   this.css = new Gtk.CssProvider();",
        "\ttry {",
        "\t\tthis.css.load_from_data(\"#left-tree-view { font-size: 10px;}\".data);",
        "\t} catch (Error e) {}",
        "\tthis.el.get_style_context().add_provider(this.css,",
        "\t\tGtk.STYLE_PROVIDER_PRIORITY_APPLICATION);",
        "\t ",
        "\t ",
        "     ",
        "    var selection = this.el.get_selection();",
        "    selection.set_mode( Gtk.SelectionMode.SINGLE);",
        "",
        "",
        "    // is this really needed??",
        "    /*",
        "    this.selection.signal['changed'].connect(function() {",
        "\t    _this.get('/LeftTree.view').listeners.cursor_changed.apply(",
        "\t        _this.get('/LeftTree.view'), [ _this.get('/LeftTree.view'), '']",
        "\t    );",
        "    });",
        "    */",
        "    Gtk.drag_source_set (",
        "\t    this.el,            /* widget will be drag-able */",
        "\t    Gdk.ModifierType.BUTTON1_MASK,       /* modifier that will start a drag */",
        "\t    BuilderApplication.targetList,            /* lists of target to support */",
        "\t    Gdk.DragAction.COPY   | Gdk.DragAction.MOVE    |  Gdk.DragAction.LINK           /* what to do with data after dropped */",
        "    );",
        "",
        "    // ?? needed??",
        "    //Gtk.drag_source_add_text_targets(this.el); ",
        "",
        "    Gtk.drag_dest_set",
        "    (",
        "        this.el,              /* widget that will accept a drop */",
        "        Gtk.DestDefaults.MOTION  | Gtk.DestDefaults.HIGHLIGHT,",
        "        BuilderApplication.targetList,            /* lists of target to support */",
        "        Gdk.DragAction.COPY   | Gdk.DragAction.MOVE   | Gdk.DragAction.LINK     /* what to do with data after dropped */",
        "    );",
        "",
        "    //Gtk.drag_dest_set_target_list(this.el, Builder.Application.targetList);",
        "    //Gtk.drag_dest_add_text_targets(this.el);",
        "    ",
        "    ",
        "   ",
        "    ",
        "}",
        ""
       ],
       "* pack" : "set_child",
       "Boolean id" : "view",
       "Gtk.CssProvider css" : "",
       "bool button_is_pressed" : false,
       "bool expand" : true,
       "bool headers_visible" : false,
       "items" : [
        {
         "$ xns" : "Gtk",
         "listeners" : {
          "pressed" : [
           "(n_press, x, y) => {",
           " ",
           "    //console.log(\"button press?\");",
           "    _this.view.button_is_pressed = true;",
           "    print(\"BUTTON DOWN\\n\");",
           "    ",
           "    _this.view.lastEventSource = \"tree\";",
           "    if (! _this.before_node_change() ) {",
           "    ",
           "       return ;",
           "    }",
           "    ",
           "\t ",
           "    if (_this.model.el.iter_n_children(null) < 1) {",
           "\t    _this.main_window.windowstate.showAddObject(_this.view.el);",
           "\t    return ;",
           "    }",
           "    ",
           "   ",
           "    Gtk.TreePath res;",
           "    Gtk.TreeViewColumn col;",
           "    if (!_this.view.el.get_path_at_pos((int)x,(int)y, out res, out col, null, null) ) {",
           "        return ;",
           "    }",
           "    ",
           "    if (col.title == \"Add\") {",
           " \t\tGLib.Value value;",
           " \t\tGtk.TreeIter iter;",
           "",
           "\t\t_this.model.el.get_iter (out  iter, res);",
           "        _this.model.el.get_value(iter, 2, out value);\t\t",
           "            // why dup_ - gets and and inc's ref count (which in theory should be freed at the end.?",
           "            ",
           "        var node = (JsRender.Node)value.dup_object();",
           "        var fqn = node.fqn();",
           "    \tvar cn = _this.main_window.windowstate.project.palete.getChildList(fqn);",
           "  \t\tif (cn.length < 1) {",
           "  \t\t\treturn ;",
           "\t\t}",
           "    ",
           "         _this.main_window.windowstate.leftTreeBeforeChange();",
           "         _this.view.el.get_selection().select_path(res);",
           "     \t_this.main_window.windowstate.showAddObject(_this.view.el);",
           "     \treturn ;",
           "     }",
           "    ",
           "\tif (  this.el.button != 3) {",
           "        //print(\"click\" + ev.type);",
           "        return ;",
           "     }",
           "    _this.main_window.windowstate.leftTreeBeforeChange();",
           "",
           "    ",
           "     ",
           "    _this.view.el.get_selection().select_path(res);",
           "     ",
           "      ",
           "     ",
           "      //if (!this.get('/LeftTreeMenu').el)  { ",
           "      //      this.get('/LeftTreeMenu').init(); ",
           "      //  }",
           "        ",
           "          var  r = Gdk.Rectangle() {",
           "    \t\t\tx = (int) x, // align left...",
           "    \t\t\ty = (int) y,",
           "    \t\t\twidth = 1,",
           "    \t\t\theight = 1",
           "    \t\t};",
           "    \t\t_this.LeftTreeMenu.el.show();",
           "\t\t _this.LeftTreeMenu.el.set_pointing_to( r);",
           "",
           "     ",
           "     //   print(\"click:\" + res.path.to_string());",
           "      return ;",
           "}",
           ""
          ],
          "released" : [
           "(n_press, x, y) => {",
           " ",
           "    _this.view.button_is_pressed = false;",
           "",
           "",
           "}",
           ""
          ]
         },
         "xtype" : "GestureClick"
        },
        {
         "# DialogTemplateSelect template_select" : "null",
         "# string activePath" : "\"\"",
         "$ columns" : [
          "typeof(string),",
          "typeof(string),",
          "typeof(Object),",
          "typeof(Gdk.Pixbuf),",
          "typeof(Gdk.Pixbuf)"
         ],
         "$ listAllTypes" : [
          "function() {",
          "    var s = this.get('/LeftTree.view').selection;",
          "    print (\"LIST ALL TYPES: \" + s.count_selected_rows() );",
          "    ",
          "    if (s.count_selected_rows() > 0) {",
          "        var iter = new Gtk.TreeIter();    ",
          "        s.get_selected(this.el, iter);",
          "",
          "        // set some properties of the tree for use by the dropped element.",
          "        var value = new GObject.Value('');",
          "        this.el.get_value(iter, 2, value);",
          "        var data = JSON.parse(value.value);",
          "        ",
          "        ",
          "        var xname = this.get('/LeftTree.model').file.guessName(data);",
          "        console.log('selected:' + xname);",
          "        if (xname.length) {",
          "            return [ xname ];",
          "        }",
          "        return []; // could not find it..",
          "    }",
          "    ",
          "    var ret = [ ];",
          "    ",
          "   var _this = this;",
          "    function addall(li)",
          "    {",
          "        li.forEach(function(el) {",
          "            // this is specific to roo!!!?",
          "            if (!el) { // skip empty?",
          "                return;",
          "            }",
          "            var fullpath =  _this.file.guessName(el);",
          "            if (fullpath.length && ret.indexOf(fullpath) < 0) {",
          "                ret.push(fullpath);",
          "            }",
          "            ",
          "            ",
          "            if (el.items && el.items.length) {",
          "                addall(el.items);",
          "            }",
          "            ",
          "        });",
          "        ",
          "        ",
          "    }",
          "    ",
          "    addall([this.currentTree]);",
          "    ",
          "    // only if we have nothing, should we add '*top'",
          "    if (!ret.length) {",
          "        ret = [ '*top' ];",
          "    }",
          "    //console.log('all types in tree');",
          "    //console.dump(ret);",
          "    ",
          "    return ret;",
          "                            ",
          "}",
          ""
         ],
         "$ xns" : "Gtk",
         "* init" : [
          "print(\"model initialized\");",
          "",
          ""
         ],
         "* pack" : "set_model",
         "currentTree" : false,
         "id" : "model",
         "n_columns" : 5,
         "xtype" : "TreeStore",
         "| JsRender.Node pathToNode" : [
          "(string path) {",
          " ",
          "     ",
          "     Gtk.TreeIter   iter;",
          "     _this.model.el.get_iter_from_string(out iter, path);",
          "     ",
          "     GLib.Value value;",
          "     _this.model.el.get_value(iter, 2, out value);",
          "     ",
          "     return (JsRender.Node)value.dup_object();",
          "",
          "}"
         ],
         "| string findDropNode" : [
          " (string treepath_str, string[] targets) {",
          "",
          "    // this is used by the dragdrop code in the roo version AFAIR..",
          "",
          "    //var path = treepath_str.replace(/^builder-/, '');",
          "    // treemap is depreciated... - should really check if model has any entries..",
          "",
          "    if (this.el.iter_n_children(null) < 1) {",
          "        //print(\"NO KEYS\");",
          "        return \"|%d\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);",
          "    }",
          "    //print(\"FIND treepath: \" + path);",
          "    //console.dump(this.treemap);",
          "    ",
          "    //if (!treepath_str.match(/^builder-/)) {",
          "    //    return []; // nothing!",
          "    //}",
          "    if (targets.length > 0 && targets[0] == \"*\") {",
          "        return  treepath_str;",
          "    }",
          "    return this.findDropNodeByPath(treepath_str,targets, -1);",
          "}",
          ""
         ],
         "| string findDropNodeByPath" : [
          " (string treepath_str, string[] targets, int in_pref = -1) {",
          "",
          "    var path = treepath_str; // dupe it..",
          "    ",
          "    ",
          "    // pref : 3 = ontop - 0 = after, 1 = before",
          "    int pref = in_pref < 0  ?  (int)Gtk.TreeViewDropPosition.INTO_OR_AFTER : in_pref;",
          "    ",
          "    var last = \"\";",
          "    ",
          "    //console.dump(this.treemap);",
          "    ",
          "    print(\"findDropNodeByPath : got path length %d / %s\\n\", path.length, path);",
          "    ",
          "    if (path.length == 0) {",
          "        // top drop. // just return empty..",
          "        return \"|%d\".printf((int)pref) ;",
          "        ",
          "    }",
          "    ",
          "    ",
          "    while (path.length > 0) {",
          "    ",
          "        if (path.length == treepath_str.length && pref != Gtk.TreeViewDropPosition.INTO_OR_AFTER) {",
          "            if (path.last_index_of(\":\") < 0 ) {",
          "                return \"\";",
          "            }",
          "            path = path.substring(0, path.last_index_of(\":\"));",
          "            last = treepath_str;",
          "            print(\"DROP  before or after : using %s\\n\",path);",
          "            continue;",
          "        }",
          "    ",
          "        //print(\"LOOKING FOR PATH: \" + path);",
          "        var node_data = this.pathToNode(path);",
          "        ",
          "        if (node_data == null) {",
          "            print(\"node not found\");",
          "            return \"\";",
          "        }",
          "        ",
          "        var xname = node_data.fqn();",
          "        var match = \"\";",
          "        var prop = \"\";",
          "        ",
          "        for (var i =0; i < targets.length; i++)  {",
          "            var tg = targets[i];",
          "            if ((tg == xname)  ) {",
          "                match = tg;",
          "                break;",
          "            }",
          "            // if target is \"xxxx:name\"",
          "            if (tg.contains(xname +\":\")) {",
          "                match = tg;",
          "                var ar = tg.split(\":\");",
          "                prop = ar[1];",
          "                break;",
          "            }",
          "        }",
          "        ",
          "        if (match.length > 0) {",
          "            if (last.length > 0) { // pref is after/before..",
          "                // then it's after last",
          "                //if (pref > 1) {",
          "                //    return \"\";",
          "                //}",
          "                return last + \"|%d\".printf((int)pref) + \"|\" + prop;",
          "",
          "                ",
          "            }",
          "            // we need to add prop - as :store -> needs to bee added when dropping onto.",
          "            return path + \"|%d\".printf( (int) Gtk.TreeViewDropPosition.INTO_OR_AFTER)  + \"|\" + prop;",
          "        }",
          "        /*",
          "        last = \"\" + path;",
          "        var par = path.split(\":\");",
          "        string [] ppar = {};",
          "        for (var i = 0; i < par.length-1; i++) {",
          "            ppar += par[i];",
          "        }",
          "        ",
          "        path = string.joinv(\":\", ppar);",
          "        */",
          "        break;",
          "",
          "    }",
          "    ",
          "    return \"\";",
          "            ",
          "}",
          ""
         ],
         "| string treePathFromNode" : [
          "(JsRender.Node node) {",
          "    // iterate through the tree and find the node",
          "    var ret = \"\";",
          "    ",
          "    this.el.foreach((mod, pth, iter) => {",
          "        // get the node..",
          "      ",
          "     ",
          "         GLib.Value value;",
          "         _this.model.el.get_value(iter, 2, out value);",
          "         ",
          "",
          "         ",
          "         var n = (JsRender.Node)value;",
          "",
          "         print(\"compare %s to %s\\n\", n.fqn(), node.fqn());",
          "        if (node == n) {",
          "            ret = pth.to_string();",
          "            return true;",
          "        }",
          "        return false;",
          "    });",
          "    return ret;",
          "",
          "}",
          ""
         ],
         "| void deleteSelected" : [
          "() {",
          "    ",
          "    print(\"DELETE SELECTED?\");",
          "    //_this.view.blockChanges = true;",
          "    print(\"GET SELECTION?\");",
          "",
          "    var s = _this.view.el.get_selection();",
          "    ",
          "    print(\"GET  SELECTED?\");",
          "   Gtk.TreeIter iter;",
          "    Gtk.TreeModel mod;",
          "",
          "    ",
          "    if (!s.get_selected(out mod, out iter)) {",
          "        return; // nothing seleted..",
          "    }",
          "      ",
          "",
          "",
          "    this.activePath= \"\";      ",
          "    print(\"GET  vnode value?\");",
          "",
          "    GLib.Value value;",
          "    this.el.get_value(iter, 2, out value);",
          "    var data = (JsRender.Node)(value.get_object());",
          "    print(\"removing node from Render\\n\");",
          "    if (data.parent == null) {",
          "       _this.main_window.windowstate.file.tree = null;",
          "    } else {",
          "        data.remove();",
          "    }",
          "    print(\"removing node from Tree\\n\");    ",
          "    s.unselect_all();",
          "    this.el.remove(ref iter);",
          "",
          "    ",
          "    ",
          "    ",
          "    // ",
          "    ",
          "    ",
          "",
          "",
          "    this.activePath= \"\"; // again!?!?      ",
          "    //this.changed(null,true);",
          "    ",
          "    _this.changed();",
          "    ",
          "    _this.view.blockChanges = false;",
          "}",
          ""
         ],
         "| void dropNode" : [
          "(string target_data_str, JsRender.Node node, bool show_templates) {",
          "//         print(\"drop Node\");",
          "     // console.dump(node);",
          "  //    console.dump(target_data);",
          "  ",
          "  \t\t//target_data_str",
          "  \t\t//   {parent}|{pos}|{prop}",
          "  ",
          "  ",
          "        // 0 = before , 1=after 2/3 onto",
          "  ",
          "  \t\tGLib.debug(\"dropNode %s\", target_data_str);",
          "        ",
          "        var target_data= target_data_str.split(\"|\");",
          "  ",
          "        var parent_str = target_data[0].length > 0 ? target_data[0] : \"\";",
          "        var pos = target_data.length > 1 ? int.parse(target_data[1]) : 2; // ontop..",
          "  ",
          "  ",
          "        Gtk.TreePath tree_path  =   parent_str.length > 0 ? new  Gtk.TreePath.from_string( parent_str ) : null;",
          "        ",
          "        ",
          "        ",
          "        //print(\"add \" + tp + \"@\" + target_data[1]  );",
          "        ",
          "        JsRender.Node parentNode = null;",
          "        ",
          "        Gtk.TreeIter iter_after;",
          "        Gtk.TreeIter iter_par ;",
          "        ",
          "       \t// this appears to be done in drag_ddata_recieved as well.",
          "         if (target_data.length == 3 && target_data[2].length > 0) {",
          "\t         node.set_prop(new JsRender.NodeProp.special(\"prop\", target_data[2]));",
          "",
          "        }",
          "",
          "        Gtk.TreePath expand_parent = null;",
          "        ",
          "        // we only need to show the template if it's come from else where?",
          "         if (show_templates) {",
          "         ",
          "             var ts = _this.main_window.windowstate.template_select;",
          "         ",
          "             var new_node = ts.show(",
          "                  _this.main_window, // (Gtk.Window) _this.el.get_toplevel (),",
          "                 _this.main_window.windowstate.file.palete(),",
          "                    node,",
          "                    _this.main_window.windowstate.project);",
          "                   ",
          "             if (new_node == null) {",
          "                 return; // do not add?",
          "             }",
          "             node = new_node;",
          "        }        ",
          "        ",
          "         //print(\"pos is %d  \\n\".printf(pos));",
          "        ",
          "         Gtk.TreeIter n_iter; ",
          "         ",
          "         if ( parent_str.length < 1) {",
          "              this.el.append(out n_iter, null); // drop at top level..",
          "              node.parent = null;",
          "              _this.main_window.windowstate.file.tree = node;",
          "              ",
          "              ",
          "        } else   if (pos  < 2) {",
          "            //print(target_data[1]  > 0 ? 'insert_after' : 'insert_before');",
          "            ",
          "            this.el.get_iter(out iter_after, tree_path );            ",
          "            this.el.iter_parent(out iter_par, iter_after);",
          "            expand_parent = this.el.get_path(iter_par);",
          "            ",
          "            ",
          "            // not sure why all the 'dup_object()' stuff? did it crash before?",
          "            GLib.Value value;",
          "            this.el.get_value( iter_par, 2, out value);",
          "            parentNode =  (JsRender.Node)value.dup_object();",
          "            ",
          "            ",
          "            this.el.get_value( iter_after, 2, out value);",
          "            var relNode =  (JsRender.Node)value.dup_object();",
          "            ",
          "            if ( pos  > 0 ) {",
          "             ",
          "                this.el.insert_after(out n_iter,    iter_par  , iter_after);",
          "                var ix = parentNode.items.index_of(relNode);",
          "                parentNode.items.insert(ix+1, node);",
          "                ",
          "            } else {",
          "                this.el.insert_before(out n_iter,  iter_par  , iter_after);",
          "                var ix = parentNode.items.index_of(relNode);",
          "                parentNode.items.insert(ix, node);",
          " ",
          "            }",
          "            node.parent = parentNode;",
          "            ",
          "            ",
          "            ",
          "        } else {",
          "           //  print(\"appending to  \" + parent_str);",
          "            this.el.get_iter(out iter_par, tree_path);",
          "            this.el.append(out n_iter,   iter_par );",
          "            expand_parent = this.el.get_path(iter_par);",
          "            ",
          "            GLib.Value value;",
          "            this.el.get_value( iter_par, 2, out value);",
          "            parentNode =  (JsRender.Node)value.dup_object();",
          "            node.parent = parentNode;",
          "            parentNode.items.add(node);",
          "        }",
          "        ",
          "        ",
          "        ",
          "        ",
          "        // work out what kind of packing to use.. -- should be in ",
          "       ",
          "            ",
          "            //_this.main_window.windowstate.file.palete().fillPack(node,parentNode);",
          "        _this.main_window.windowstate.file.palete().on_child_added(parentNode,node);",
          "            ",
          "          ",
          "        this.iterSetValues(n_iter, node);",
          "        // add the node...",
          "         ",
          "        ",
          "        ",
          "\t\t// load children - if it has any..",
          "      ",
          "        if (node.items.size > 0) {",
          "            this.load(node.items, n_iter);",
          "            _this.view.el.expand_row(this.el.get_path(n_iter), true);",
          "        } else if (expand_parent != null && !_this.view.el.is_row_expanded(expand_parent)) {",
          "           _this.view.el.expand_row(expand_parent,true);",
          "        }",
          "",
          "        //if (tp != null && (node.items.length() > 0 || pos > 1)) {",
          "        //    _this.view.el.expand_row(this.el.get_path(iter_par), true);",
          "       // }",
          "        // wee need to get the empty proptypes from somewhere..",
          "        ",
          "        //var olditer = this.activeIter;",
          "        this.activePath = this.el.get_path(n_iter).to_string();",
          "",
          "",
          "        // pretend button was pressed, so that we can trigger select node...",
          "        _this.view.button_is_pressed = true;",
          "        _this.view.lastEventSource = \"\";",
          "        _this.view.el.set_cursor(this.el.get_path(n_iter), null, false);",
          "        _this.view.button_is_pressed = false;",
          "        _this.changed();",
          "     ",
          "        ",
          "            ",
          "}",
          ""
         ],
         "| void iterSetValues" : [
          "(Gtk.TreeIter iter, JsRender.Node node)   {",
          "",
          " ",
          "\tvar ic = Gtk.IconTheme.get_for_display(this.el.get_display());",
          "    Gdk.Pixbuf pix = null,addi = null;",
          "    ",
          "    var o =   GLib.Value(typeof(Object));",
          "    o.set_object((Object)node);",
          "    var clsname = node.fqn();",
          "    ",
          "    var clsb = clsname.split(\".\");",
          "    var sub = clsb.length > 1 ? clsb[1].down()  : \"\";",
          "    ",
          "    ",
          "    var fn = \"/usr/share/glade/pixmaps/hicolor/16x16/actions/widget-gtk-\" + sub + \".png\";",
          "    try { ",
          "\t\taddi =  ic.load_icon(\"list-add\", 16,0);",
          "\t\tif (FileUtils.test (fn, FileTest.IS_REGULAR)) {",
          "\t\t\t",
          "\t\t    \tpix = new Gdk.Pixbuf.from_file (fn);",
          "\t\t\t",
          "\t\t}  else {",
          "\t\t \tpix = ic.load_icon(\"emblem-new\", 16,0);",
          "\t \t}",
          " \t} catch (GLib.Error e) {}",
          "    ",
          "    var fqn = node.fqn();",
          "    var cn = _this.main_window.windowstate.project.palete.getChildList(fqn);",
          "    ",
          "    this.el.set(",
          "    \t\titer, ",
          "    \t\t0, node.nodeTitle(),",
          "            1, node.nodeTip(), ",
          "            -1",
          "    );",
          "    this.el.set_value(iter, 2,o);",
          "    this.el.set_value(iter, 3,pix);    ",
          "  \tthis.el.set_value(iter, 4, cn.length > 0 ? addi : null);   ",
          "    ",
          "",
          "}"
         ],
         "| void load" : [
          "(Gee.ArrayList<JsRender.Node> tr, Gtk.TreeIter? iter) ",
          "{",
          "    ",
          "  \t",
          "    Gtk.TreeIter citer;",
          "    //this.insert(citer,iter,0);",
          "   ",
          "    ",
          "    for(var i =0 ; i < tr.size; i++) {",
          "        if (iter != null) {",
          "            this.el.insert(out citer,iter,-1); // why not append?",
          "        } else {",
          "            this.el.append(out citer,null);",
          "        }",
          "        this.iterSetValues(citer, tr.get(i));",
          "        ",
          " ",
          "         ",
          "        if (tr.get(i).items.size > 0) {",
          "            this.load(tr.get(i).items, citer);",
          "        }",
          "     ",
          "    }",
          "",
          "    ",
          "}"
         ],
         "| void loadFile" : [
          "(JsRender.JsRender f) {",
          "    //console.dump(f);",
          "    this.el.clear();",
          "    _this.main_window.windowstate.leftTreeNodeSelected(null, \"\");",
          "    // needed???",
          "    _this.main_window.windowstate.file = f;",
          "    ",
          "   ",
          "    if (f.tree == null) {",
          "\t    try {",
          "\t        f.loadItems( );",
          "        } catch (Error e) {",
          "    \t\treturn;",
          "        }",
          "    }",
          "    // if it's still null?",
          "    if (f.tree == null) {",
          "\t\t_this.main_window.windowstate.showAddObject(_this.view.el);",
          "    ",
          "        return;",
          "    }",
          "  ",
          "    var o = new Gee.ArrayList<JsRender.Node>();",
          "    o.add(f.tree);",
          "    this.load(o,null);",
          "    ",
          "    _this.view.el.expand_all();",
          "",
          "    if (f.tree.items.size < 1) {",
          "        // single item..",
          "        ",
          "        //this.get('/Window.leftvpaned').el.set_position(80);",
          "        // select first...",
          "        _this.view.el.set_cursor( ",
          "            new  Gtk.TreePath.from_string(\"0\"), null, false);",
          "        ",
          "        ",
          "    } else {",
          "          //this.get('/Window.leftvpaned').el.set_position(200);",
          "    }",
          "    ",
          "    ",
          "    ",
          "",
          "    _this.maincol.el.set_max_width(_this.viewwin.el.get_allocated_width() - 32);",
          " ",
          "    ",
          "   ",
          "    return;",
          " ",
          "            ",
          "}",
          ""
         ],
         "| void moveNode" : [
          "(string target_data, Gdk.DragAction action) ",
          "{",
          "   ",
          "   /// target_data = \"path|pos\");",
          "   ",
          "   ",
          "    //print(\"MOVE NODE\");",
          "    // console.dump(target_data);",
          "    Gtk.TreeIter old_iter;",
          "    Gtk.TreeModel mod;",
          "    ",
          "    var s = _this.view.el.get_selection();",
          "    s.get_selected(out mod , out old_iter);",
          "    mod.get_path(old_iter);",
          "    ",
          "    var node = this.pathToNode(mod.get_path(old_iter).to_string());",
          "    //console.dump(node);",
          "    if (node == null) {",
          "        GLib.debug(\"moveNode: ERROR - node is null?\");",
          "    }",
          "    ",
          "    ",
          "",
          "    // needs to drop first, otherwise the target_data ",
          "    // treepath will be invalid.",
          "",
          "    ",
          "    if ((action & Gdk.DragAction.MOVE) > 0) {",
          "            GLib.debug(\"REMOVING OLD NODE : \" + target_data + \"\\n\");",
          "            node.remove();",
          "            this.dropNode(target_data, node, false);",
          "            this.el.remove(ref old_iter);",
          "            ",
          "            ",
          "                         ",
          "    } else {",
          "        GLib.debug(\"DROPPING NODE // copy: \" + target_data + \"\\n\");",
          "        node = node.deepClone();",
          "        this.dropNode(target_data, node, false);",
          "    }",
          "    _this.changed();",
          "    this.activePath= \"\";",
          "    //this.updateNode(false,true);",
          "}",
          ""
         ],
         "| void updateSelected" : [
          "() {",
          "  ",
          "   ",
          "    var s = _this.view.el.get_selection();",
          "    ",
          "     Gtk.TreeIter iter;",
          "    Gtk.TreeModel mod;",
          "    ",
          "    ",
          "    ",
          "    if (!s.get_selected(out mod, out iter)) {",
          "        return; // nothing seleted..",
          "    }",
          "  ",
          "  GLib.Value value;",
          "    this.el.get_value(iter, 2, out value);",
          "    var node = (JsRender.Node)(value.get_object());",
          "    ",
          "      this.el.set(iter, 0, node.nodeTitle(),",
          "                1, node.nodeTip(), -1",
          "        );",
          "}",
          ""
         ]
        },
        {
         "$ Gtk.TreeViewColumnSizing sizing" : "Gtk.TreeViewColumnSizing.FIXED",
         "$ xns" : "Gtk",
         "* init" : [
          "  this.el.add_attribute(_this.renderer.el , \"markup\", 0 );",
          "  this.el.add_attribute(_this.iconrender.el , \"pixbuf\",  3 );",
          " "
         ],
         "* pack" : "append_column",
         "bool expand" : true,
         "bool resizable" : true,
         "id" : "maincol",
         "items" : [
          {
           "$ xns" : "Gtk",
           "* pack" : "pack_start,false",
           "id" : "iconrender",
           "int width" : 16,
           "xtype" : "CellRendererPixbuf"
          },
          {
           "$ xns" : "Gtk",
           "* pack" : "pack_start,true",
           "id" : "renderer",
           "xtype" : "CellRendererText"
          }
         ],
         "utf8 title" : "Node",
         "xtype" : "TreeViewColumn"
        },
        {
         "$ Gtk.TreeViewColumnSizing sizing" : "Gtk.TreeViewColumnSizing.FIXED",
         "$ xns" : "Gtk",
         "* init" : [
          " this.el.add_attribute(_this.addiconrender.el , \"pixbuf\",  4 );",
          " "
         ],
         "* pack" : "append_column",
         "bool expand" : false,
         "int max_width" : 24,
         "items" : [
          {
           "$ xns" : "Gtk",
           "* pack" : "pack_start,true",
           "id" : "addiconrender",
           "int width" : 16,
           "xtype" : "CellRendererPixbuf"
          }
         ],
         "utf8 title" : "Add",
         "xtype" : "TreeViewColumn"
        }
       ],
       "listeners" : {
        "cursor_changed" : [
         " ( ) => {",
         "    print(\"LEFT TREE Cursor Changed\\n\");",
         "\t//if (!this.button_is_pressed && !this.key_is_pressed) {",
         "\t\t// then event was started by some other action",
         "\t\t// which should manually trigger all the events..",
         "\t//\tprint(\"SKIPPING select - no button or key pressed\\n\");",
         "\t//\treturn;",
         "\t//}",
         "",
         "",
         "     if (this.blockChanges) { // probably not needed.. ",
         "\t\tprint(\"SKIPPING select - blockchanges set..\\n\");     ",
         "       return  ;",
         "     }",
         "      if (!_this.before_node_change( ) ) {",
         "\t     this.blockChanges = true;",
         "\t     this.el.get_selection().unselect_all();",
         "\t     this.blockChanges = false;",
         "\t     ",
         "\t     return;",
         "     }",
         "     if (_this.main_window.windowstate.file == null) {",
         "   \t\tprint(\"SKIPPING select windowstate file is not set...\\n\");     ",
         "         return;",
         "     } ",
         "     ",
         "     //var render = this.get('/LeftTree').getRenderer();                ",
         "    print(\"LEFT TREE -> view -> selection changed called\\n\");",
         "    ",
         "    ",
         "    // -- it appears that the selection is not updated.",
         "      ",
         "    GLib.Timeout.add_full(GLib.Priority.DEFAULT,10 , () => {",
         "         print(\"LEFT TREE -> view -> selection changed TIMEOUT CALLED\\n\");",
         "",
         "            if (this.el.get_selection().count_selected_rows() < 1) {",
         "",
         "                print(\"selected rows < 1\\n\");",
         "                //??this.model.load( false);",
         "                _this.node_selected(null, this.lastEventSource);",
         "                ",
         "                return false ;",
         "            }",
         "                ",
         "                //console.log('changed');",
         "            var s = this.el.get_selection();",
         "             Gtk.TreeIter iter;",
         "             Gtk.TreeModel mod;",
         "            s.get_selected(out mod, out iter);",
         "            ",
         "            ",
         "            // var val = \"\";",
         "            GLib.Value value;",
         "            _this.model.el.get_value(iter, 2, out value);",
         "            _this.model.activePath = mod.get_path(iter).to_string();",
         "            ",
         "            // why dup_?",
         "            ",
         "            var node = (JsRender.Node)value.dup_object();",
         "            print (\"calling left_tree.node_selected\\n\");",
         "            _this.node_selected(node, this.lastEventSource);",
         "           ",
         "            var cp = mod.get_path(iter);",
         "            Gtk.TreePath sp, ep;",
         "            this.el.get_visible_range(out sp, out ep);",
         "            // if sp is before cp then retuns 1.",
         "            // if cp is before ep then retuns 1.",
         "            if (cp.compare(sp) >= 0 && ep.compare(cp) >=1) {",
         "                return false;",
         "            }",
         "            ",
         "             ",
         "            ",
         "            this.el.scroll_to_cell(new Gtk.TreePath.from_string(_this.model.activePath), null, true, 0.1f,0.0f);",
         "            ",
         "            return false;",
         "      });  ",
         "    //_this.after_node_change(node);",
         "",
         "//        _this.model.file.changed(node, \"tree\");",
         "   ",
         "    //Seed.print( value.get_string());",
         "    return  ;",
         "                ",
         "}"
        ],
        "drag_begin" : [
         "( ctx)  => {",
         "\t//print('SOURCE: drag-begin');",
         "        ",
         "        ",
         "        //this.targetData = \"\";",
         "        ",
         "        // find what is selected in our tree...",
         "        ",
         "        var s = _this.view.el.get_selection();",
         "        if (s.count_selected_rows() < 1) {",
         "            return;",
         "        }",
         "        Gtk.TreeIter iter;",
         "        Gtk.TreeModel mod;",
         "        s.get_selected(out mod, out iter);",
         "",
         "        ",
         "",
         "        // set some properties of the tree for use by the dropped element.",
         "        GLib.Value value;",
         "        _this.model.el.get_value(iter, 2, out value);",
         "        var tp = mod.get_path(iter).to_string();",
         "        var data = (JsRender.Node)(value.dup_object());",
         "        var xname = data.fqn();",
         "        print (\"XNAME  IS \" + xname+ \"\\n\");",
         "        this.dragData = tp;",
         "        this.dropList = _this.main_window.windowstate.file.palete().getDropList(xname);",
         "        ",
         "        print (\"DROP LIST IS \" + string.joinv(\", \", this.dropList) + \"\\n\");",
         "        ",
         "",
         "        // make the drag icon a picture of the node that was selected",
         "    ",
         "        ",
         "    // by default returns the path..",
         "       var path = _this.model.el.get_path(iter);",
         "",
         "         ",
         "        var pix = this.el.create_row_drag_icon ( path);",
         "        ",
         "        Gtk.drag_set_icon_surface (ctx, pix) ;",
         "        ",
         "        return;",
         "}"
        ],
        "drag_data_get" : [
         "( drag_context, data, info, time) => {",
         "            ",
         "",
         "\t//print(\"drag-data-get\");",
         "\tvar s = this.el.get_selection();",
         "\tif (s.count_selected_rows() < 1) {",
         "\t\tdata.set_text(\"\",0);     ",
         "\t\t print(\"return empty string - no selection..\");",
         "\t\treturn;",
         "\t}",
         "",
         "\tGtk.TreeIter iter;",
         "\tGtk.TreeModel mod;",
         "",
         "\ts.get_selected(out mod, out iter);",
         "",
         "",
         "",
         "\tGLib.Value value;",
         "\t_this.model.el.get_value(iter, 2, out value);",
         "\tvar ndata = (JsRender.Node)(value.dup_object());",
         "",
         "",
         "",
         "\tvar tp = mod.get_path(iter).to_string();",
         "\t// by default returns the path..",
         "",
         "\tif ( info != Gdk.Atom.intern(\"STRING\",true) ) {",
         "\t\ttp = ndata.toJsonString();",
         "\t}   ",
         "",
         "\t//data.set_text(tp,tp.length);   ",
         "",
         "\tdata.set (data.get_target (), 8, (uchar[]) tp.to_utf8 ());",
         "",
         "",
         "\t//  print(\"return \" + tp);",
         "\t}"
        ],
        "drag_data_received" : [
         "\t(ctx, x, y, sel, info, time)  => {",
         "",
         "\t// THIS CODE ONLY RELATES TO drag  or drop of \"NEW\" elements or \"FROM another tree..\"",
         "",
         "",
         "\t//  print(\"Tree: drag-data-received\\n\");",
         "\tvar selection_text = (string)sel.get_data();",
         "\t//print(\"selection_text= %s\\n\",selection_text);",
         "",
         "\tvar is_drag = this.drag_in_motion;",
         "",
         "",
         "",
         "\tGLib.debug(\"Is Drag %s\\n\", is_drag ? \"Y\": \"N\");",
         "\tvar  targetData = \"\";",
         "",
         "\tGtk.TreePath path;",
         "\tGtk.TreeViewDropPosition pos;",
         "\tvar isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);",
         "",
         "\t// if there are not items in the tree.. the we have to set isOver to true for anything..",
         "\tvar isEmpty = false;",
         "\tif (_this.model.el.iter_n_children(null) < 1) {",
         "\t\tGLib.debug(\"got NO children?\\n\");",
         "\t\tisOver = true; //??? ",
         "\t\tisEmpty = true;",
         "\t\tpos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;",
         "\t}",
         "",
         "",
         "\t//console.log(\"LEFT-TREE: drag-motion\");",
         "\tvar src = Gtk.drag_get_source_widget(ctx);",
         "",
         "\t// a drag from self - this should be handled by drop and motion.",
         "\tif (src == this.el) {",
         "\t\tGLib.debug(\"Source == this element should not happen.. ? \\n\");",
         "\t\treturn;",
         "\t}",
         "\t//print(\"drag_data_recieved from another element\");",
         "",
         "\t ",
         "",
         "",
         "\tif (selection_text == null || selection_text.length < 1 || !isOver) {",
         "\t\t// nothing valid foudn to drop...",
         "\t\t   GLib.debug(\"empty sel text or not over\");",
         "\t\tif (is_drag) {",
         "\t\t    Gdk.drag_status(ctx, 0, time);",
         "\t\t    this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);",
         "\t\t    return;",
         "\t\t}",
         "\t\tGtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "\t\t// no drop action...",
         "\t\treturn;            ",
         "",
         "\t}",
         "\tvar dropNode = new JsRender.Node(); ",
         "",
         "\tvar dropNodeType  = selection_text;",
         "\tvar show_templates = true;",
         "\t// for drop",
         "\tif (dropNodeType[0] == '{') {",
         "\t\tvar pa = new Json.Parser();",
         "\t\ttry {",
         "\t\t    pa.load_from_data(dropNodeType);",
         "\t\t} catch (Error e) {",
         "\t\t    Gtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "\t\t    // no drop action...",
         "\t\t    return;   ",
         "\t\t}",
         "\t\t ",
         "\t\tdropNode.loadFromJson( pa.get_root().get_object(), 2);",
         "\t\tdropNodeType = dropNode.fqn();",
         "\t\tshow_templates = false;",
         "\t\t",
         "\t\t",
         "\t} else {",
         "\t\t// drop with property.",
         "\t\tif (selection_text.contains(\":\")) {",
         "\t\t\tvar bits = selection_text.split(\":\");",
         "\t\t    dropNode.setFqn(bits[0]);",
         "\t\t    dropNode.set_prop(new JsRender.NodeProp.special(\"prop\", bits[1]));",
         "\t\t    ",
         "\t\t    ",
         "\t\t    ",
         "\t\t} else {",
         "\t\t    dropNode.setFqn(selection_text);",
         "\t\t}",
         "\t}",
         "",
         "\t ",
         "\t// dropList --- need to gather this ... ",
         "\tGLib.debug(\"get dropList for : %s\\n\",dropNodeType);            ",
         "\tvar dropList = _this.main_window.windowstate.file.palete().getDropList(dropNodeType);",
         "",
         "\tGLib.debug(\"dropList: %s\\n\", string.joinv(\" , \", dropList));",
         "",
         "\t// if drag action is link ... then we can drop it anywahere...",
         "\t if ((ctx.get_actions() & Gdk.DragAction.LINK) > 0) {",
         "\t\t // if path is null?? dragging into an empty tree?",
         "\t\t targetData = (path == null ? \"\" :  path.to_string()) + \"|%d\".printf((int)pos);",
         "\t } else {",
         "",
         "",
         "\t\ttargetData = _this.model.findDropNodeByPath( isEmpty ? \"\" : path.to_string(), dropList, pos);",
         "\t }",
         "",
         "",
         "\t\t",
         "\tGLib.debug(\"targetDAta: %s\", targetData );",
         "",
         "\tif (targetData.length < 1) {",
         "\t ",
         "\t\t// invalid drop path..",
         "\t\tif (this.drag_in_motion) {",
         "\t\t    Gdk.drag_status(ctx, 0, time);",
         "\t\t    this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);",
         "\t\t    return;",
         "\t\t}",
         "\t\tGtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "\t\t// no drop action...",
         "\t\treturn;",
         "\t}",
         "",
         "",
         "",
         "\t var td_ar = targetData.split(\"|\");",
         "\t  ",
         "",
         "\tif (this.drag_in_motion) { ",
         "\t\tGdk.drag_status(ctx, Gdk.DragAction.COPY ,time);",
         "",
         "\t\tthis.highlightDropPath(  td_ar[0]  , (Gtk.TreeViewDropPosition)int.parse(td_ar[1]));",
         "\t\treturn;",
         "\t}",
         "\t// continue on to allow drop..",
         "",
         "",
         "\t// at this point, drag is not in motion... -- as checked above... - so it's a real drop event..",
         "\t//targetData",
         "\t//   {parent}|{pos}|{prop}",
         "",
         "",
         "   _this.model.dropNode(targetData, dropNode, show_templates);",
         "    ",
         "\tGLib.debug(\"ADD new node!!!\\n\");",
         "\t\t",
         "\t///Xcls_DialogTemplateSelect.singleton().show( _this.model.file.palete(), node);",
         "",
         "\tGtk.drag_finish (ctx, false, false,time);",
         "",
         "",
         "\t\t",
         "\t\t",
         "",
         "}"
        ],
        "drag_drop" : [
         " (  ctx, x, y, time)  => {",
         "      //Seed.print(\"TARGET: drag-drop\");",
         "   ",
         "   ",
         "    var src = Gtk.drag_get_source_widget(ctx);",
         "     ",
         "   if (src != this.el) {",
         "   ",
         "    ",
         "       ",
         "       this.drag_in_motion = false;   ",
         "            // request data that will be recieved by the recieve...              ",
         "        Gtk.drag_get_data",
         "        (",
         "                this.el,         // will receive 'drag-data-received' signal ",
         "                ctx,        // represents the current state of the DnD ",
         "                Gdk.Atom.intern(\"application/json\",true),    // the target type we want ",
         "                time            // time stamp ",
         "        );",
         "",
         "         ",
         "        // No target offered by source => error",
         "   ",
         "",
         "         return  false;",
         "     }",
         "     ",
         "     // handle drop around self..",
         "     ",
         "                  ",
         "            ",
         "    //print(\"GETTING POS\");",
         "    var  targetData = \"\";",
         "    ",
         "    Gtk.TreePath path;",
         "    Gtk.TreeViewDropPosition pos;",
         "    var isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);",
         "    ",
         "    // if there are not items in the tree.. the we have to set isOver to true for anything..",
         "    var isEmpty = false;",
         "    if (_this.model.el.iter_n_children(null) < 1) {",
         "        print(\"got NO children?\\n\");",
         "        isOver = true; //??? ",
         "        isEmpty = true;",
         "        pos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;",
         "    }",
         "    ",
         "     ",
         "     ",
         "    //var action = Gdk.DragAction.COPY;",
         "        // unless we are copying!!! ctl button..",
         "    ",
         "    var action = (ctx.get_actions() & Gdk.DragAction.MOVE) > 0 ?",
         "                 Gdk.DragAction.COPY  : Gdk.DragAction.MOVE ;",
         "                // Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;",
         "",
         "      ",
         "    if (_this.model.el.iter_n_children(null) < 1) {",
         "        // no children.. -- asume it's ok..",
         "        ",
         "        targetData = \"|%d|\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);",
         "         ",
         "        // continue through to allow drop...",
         "",
         "    } else {",
         "                ",
         "                ",
         "    ",
         "                ",
         "                ",
         "                //print(\"ISOVER? \" + isOver);",
         "        if (!isOver) {",
         "            ",
         "            Gtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "            return true; // not over apoint!?! - no action on drop or motion..",
         "        }",
         "                ",
         "        // drag node is parent of child..",
         "        //console.log(\"SRC TREEPATH: \" + src.treepath);",
         "        //console.log(\"TARGET TREEPATH: \" + data.path.to_string());",
         "        ",
         "        // nned to check a  few here..",
         "        //Gtk.TreeViewDropPosition.INTO_OR_AFTER",
         "        //Gtk.TreeViewDropPosition.INTO_OR_BEFORE",
         "        //Gtk.TreeViewDropPosition.AFTER",
         "        //Gtk.TreeViewDropPosition.BEFORE",
         "        ",
         "        // locally dragged items to not really use the ",
         "        var selection_text = this.dragData;",
         "        ",
         "        ",
         "        ",
         "        if (selection_text == null || selection_text.length < 1) {",
         "            //print(\"Error  - drag selection text returned NULL\");",
         "          ",
         "             Gtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "             return true; /// -- fixme -- this is not really correct..",
         "        }                ",
         "                ",
         "                // see if we are dragging into ourself?",
         "                print (\"got selection text of  \" + selection_text);",
         "        ",
         "        var target_path = path.to_string();",
         "        //print(\"target_path=\"+target_path);",
         "",
         "        // ",
         "        if (selection_text  == target_path) {",
         "            print(\"self drag ?? == we should perhaps allow copy onto self..\\n\");",
         "            ",
         "             Gtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "",
         "             return true; /// -- fixme -- this is not really correct..",
         "",
         "        }",
         "                ",
         "        // check that ",
         "        //print(\"DUMPING DATA\");",
         "        //console.dump(data);",
         "        // path, pos",
         "        ",
         "        //print(data.path.to_string() +' => '+  data.pos);",
         "        ",
         "        // dropList is a list of xtypes that this node could be dropped on.",
         "        // it is set up when we start to drag..",
         "        ",
         "        ",
         "        targetData = _this.model.findDropNodeByPath( path.to_string(), this.dropList, pos);",
         "            ",
         "        print(\"targetDAta: \" + targetData +\"\\n\");",
         "        ",
         "        if (targetData.length < 1) {",
         "            //print(\"Can not find drop node path\");",
         "             ",
         "            Gtk.drag_finish (ctx, false, false, time);        // drop failed..",
         "            return true;",
         "        }",
         "                    ",
         "                ",
         "                ",
         "                // continue on to allow drop..",
         "  }",
         "        // at this point, drag is not in motion... -- as checked above... - so it's a real drop event..",
         "",
         "",
         "     var delete_selection_data = false;",
         "        ",
         "    if (action == Gdk.DragAction.ASK)  {",
         "        /* Ask the user to move or copy, then set the ctx action. */",
         "    }",
         "",
         "    if (action == Gdk.DragAction.MOVE) {",
         "        delete_selection_data = true;",
         "    }",
         "      ",
         "                // drag around.. - reorder..",
         "    _this.model.moveNode(targetData, action);",
         "        ",
         "       ",
         "        ",
         "        ",
         "        ",
         "        // we can send stuff to souce here...",
         "",
         "",
         "// do we always say failure, so we handle the reall drop?",
         "    Gtk.drag_finish (ctx, false, false,time); //delete_selection_data, time);",
         "",
         "    return true;",
         " ",
         " ",
         " ",
         " ",
         " ",
         " ",
         "}"
        ],
        "drag_end" : [
         "  (drag_context) => {",
         "\t//Seed.print('LEFT-TREE: drag-end');",
         "        this.dragData = \"\";",
         "        this.dropList = null;",
         "//        this.targetData = \"\";",
         "        this.highlightDropPath(\"\",0);",
         "//        return true;",
         "}"
        ],
        "drag_motion" : [
         " ( ctx, x, y, time)  => {",
         "   print(\"got drag motion\\n\");",
         "    var src = Gtk.drag_get_source_widget(ctx);",
         "   this.drag_x = x;",
         "   this.drag_y = y;     ",
         "",
         "   if (src != this.el) {",
         "   ",
         " ",
         " ",
         "    // the point of this is to detect where an item could be dropped..",
         "        print(\"requesting drag data\\n\");",
         "       this.drag_in_motion = true;",
         "       ",
         "            // request data that will be recieved by the recieve...              ",
         "        Gtk.drag_get_data",
         "        (",
         "                this.el,         // will receive 'drag-data-received' signal ",
         "                ctx,        // represents the current state of the DnD ",
         "                Gdk.Atom.intern(\"STRING\",true),    // the target type we want ",
         "                time            // time stamp ",
         "        );",
         "        return true;",
         "  }    ",
         "",
         "",
         "  print(\"action: %d\\n\", ctx.get_actions());",
         " //print(\"GETTING POS\");",
         "    var  targetData = \"\";",
         "",
         "    Gtk.TreePath path;",
         "    Gtk.TreeViewDropPosition pos;",
         "    var isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);",
         "",
         "    // if there are not items in the tree.. the we have to set isOver to true for anything..",
         "    var isEmpty = false;",
         "    if (_this.model.el.iter_n_children(null) < 1) {",
         "        print(\"got NO children?\\n\");",
         "        isOver = true; //??? ",
         "        isEmpty = true;",
         "        pos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;",
         "    }",
         "",
         "",
         "    // ------------- a drag from self..",
         "",
         "",
         "    //var action = Gdk.DragAction.COPY;",
         "        // unless we are copying!!! ctl button..",
         "    ",
         "    var action = (ctx.get_actions() & Gdk.DragAction.MOVE) > 0 ?",
         "                 Gdk.DragAction.COPY  : Gdk.DragAction.MOVE ;",
         "                // Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;",
         "",
         "",
         "    if (_this.model.el.iter_n_children(null) < 1) {",
         "        // no children.. -- asume it's ok..",
         "        ",
         "        targetData = \"|%d|\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);",
         "           ",
         "        this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);        ",
         "        Gdk.drag_status(ctx, action ,time);",
         "        return true;",
         "        ",
         "        // continue through to allow drop...",
         "",
         "    } ",
         "        ",
         "        ",
         "",
         "    ",
         "    ",
         "    //print(\"ISOVER? \" + isOver);",
         "    if (!isOver) {",
         "  ",
         "        Gdk.drag_status(ctx, 0 ,time);",
         "         this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);                    ",
         "         return false;",
         "",
         "    }",
         "            ",
         "    // drag node is parent of child..",
         "    //console.log(\"SRC TREEPATH: \" + src.treepath);",
         "    //console.log(\"TARGET TREEPATH: \" + data.path.to_string());",
         "    ",
         "    // nned to check a  few here..",
         "    //Gtk.TreeViewDropPosition.INTO_OR_AFTER",
         "    //Gtk.TreeViewDropPosition.INTO_OR_BEFORE",
         "    //Gtk.TreeViewDropPosition.AFTER",
         "    //Gtk.TreeViewDropPosition.BEFORE",
         "    ",
         "    // locally dragged items to not really use the ",
         "    var selection_text = this.dragData;",
         "    ",
         "            ",
         "            ",
         "    if (selection_text == null || selection_text.length < 1) {",
         "                //print(\"Error  - drag selection text returned NULL\");",
         "             Gdk.drag_status(ctx, 0 ,time);",
         "            this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);",
         "             return false;",
         "     }",
         "                       ",
         "            ",
         "            // see if we are dragging into ourself?",
         "    var target_path = path.to_string();            ",
         "    print (\"Drag  %s onto %s--%d\\n \", selection_text, target_path, pos);",
         "    ",
         "    // pos : 3 = ontop - 0 = after, 1 = before",
         "    //print(\"target_path=\"+target_path);",
         "",
         "    // ",
         "    if (selection_text  == target_path) {",
         "        print(\"self drag ?? == we should perhaps allow copy onto self..\\n\");",
         "                ",
         "         Gdk.drag_status(ctx, 0 ,time);",
         "          this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);",
         "          return false;",
         "//                 -- fixme -- this is not really correct..",
         "",
         "    }",
         "            ",
         "    // check that ",
         "    //print(\"DUMPING DATA\");",
         "    //console.dump(data);",
         "    // path, pos",
         "    ",
         "    //print(data.path.to_string() +' => '+  data.pos);",
         "    ",
         "    // dropList is a list of xtypes that this node could be dropped on.",
         "    // it is set up when we start to drag..",
         "    ",
         "    ",
         "    targetData = _this.model.findDropNodeByPath( path.to_string(), this.dropList, pos);",
         "        ",
         "    print(\"targetDAta: \" + targetData +\"\\n\");",
         "    ",
         "    if (targetData.length < 1) {",
         "        //print(\"Can not find drop node path\");",
         "       ",
         "        Gdk.drag_status(ctx, 0, time);",
         "        this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);",
         "        return false;",
         "    }",
         "    ",
         "    var td_ar = targetData.split(\"|\");",
         "      ",
         "    ",
         "",
         "    Gdk.drag_status(ctx, action ,time);",
         "    this.highlightDropPath(td_ar[0], (Gtk.TreeViewDropPosition)int.parse(td_ar[1]));",
         "    return true;",
         "       ",
         "       ",
         "}"
        ]
       },
       "string name" : "left-tree-view",
       "tooltip_column" : 1,
       "xtype" : "TreeView",
       "| void highlightDropPath" : [
        " ( string treepath, Gtk.TreeViewDropPosition pos) {",
        "",
        "        // highlighting for drag/drop",
        "        if (treepath.length > 0) {",
        "            this.el.set_drag_dest_row(  new  Gtk.TreePath.from_string( treepath ), pos);",
        "          } else {",
        "            this.el.set_drag_dest_row(null, Gtk.TreeViewDropPosition.INTO_OR_AFTER);",
        "         }",
        "             ",
        "}"
       ],
       "| void selectNode" : [
        "(string treepath_str, string source) {",
        "\tthis.lastEventSource = source;",
        "    //this.selection.select_path(new  Gtk.TreePath.from_string( treepath_str));",
        "     var tp = new Gtk.TreePath.from_string(treepath_str);",
        "     ",
        "     this.el.set_cursor(tp, null, false);  ",
        "     this.el.scroll_to_cell(tp, null, false, 0,0);",
        "}",
        ""
       ],
       "| void setCursor" : [
        "(string treepath, string sourceEvent)   {",
        "\tthis.lastEventSource = sourceEvent;",
        "\t//this.blockChanges = true; << block changes prevents loading of 'node data' and firing of node_selected..",
        "    this.el.set_cursor(new Gtk.TreePath.from_string(treepath), null, false); ",
        "    // fire node_selected..",
        "    //this.blockChanges = false;",
        "\tthis.lastEventSource = \"\";",
        "}",
        ""
       ]
      },
      {
       "$ xns" : "Gtk",
       "* pack" : false,
       "id" : "LeftTreeMenu",
       "items" : [
        {
         "$ xns" : "Gtk",
         "* prop" : "child",
         "Gtk.Orientation orientation" : "Gtk.Orientation.VERTICAL",
         "int spacing" : 0,
         "items" : [
          {
           "$ xns" : "Gtk",
           "label" : "Delete Element",
           "listeners" : {
            "activate" : [
             "  ( ) => {",
             "    ",
             "    print(\"ACTIVATE?\");",
             "    ",
             "  ",
             "     _this.model.deleteSelected();",
             "}"
            ]
           },
           "xtype" : "Button"
          },
          {
           "$ xns" : "Gtk",
           "label" : "Save as Template",
           "listeners" : {
            "activate" : [
             "  () => {",
             "",
             "     DialogSaveTemplate.singleton().show(",
             "            (Gtk.Window) _this.el.get_toplevel (), ",
             "            _this.main_window.windowstate.file.palete(), ",
             "            _this.getActiveElement()",
             "    );",
             "     ",
             "    ",
             "}"
            ]
           },
           "xtype" : "Button"
          },
          {
           "$ xns" : "Gtk",
           "label" : "Save as Module",
           "listeners" : {
            "activate" : [
             "  () => {",
             "    var node = _this.getActiveElement();",
             "     var name = DialogSaveModule.singleton().show(",
             "            (Gtk.Window) _this.el.get_toplevel (), ",
             "            _this.main_window.windowstate.project, ",
             "            node",
             "     );",
             "     if (name.length < 1) {",
             "            return;",
             "  ",
             "     }",
             "     node.set_prop( new JsRender.NodeProp.special(\"xinclude\", name));",
             "     node.items.clear();",
             "",
             "",
             "    var s = _this.view.el.get_selection();",
             "    ",
             "    print(\"GET  SELECTED?\");",
             "    Gtk.TreeIter iter;",
             "    Gtk.TreeModel mod;",
             "",
             "    ",
             "    if (!s.get_selected(out mod, out iter)) {",
             "        return; // nothing seleted..",
             "    }",
             "    Gtk.TreeIter citer;",
             "    var n_cn = mod.iter_n_children(iter) -1;",
             "    for (var i = n_cn; i > -1; i--) {",
             "        mod.iter_nth_child(out citer, iter, i);",
             "        ",
             "",
             "        print(\"removing node from Tree\\n\");    ",
             "    ",
             "        _this.model.el.remove(ref citer);",
             "    }",
             "    _this.changed();",
             "    _this.node_selected(node, \"tree\");",
             "     ",
             "    ",
             "}"
            ]
           },
           "xtype" : "Button"
          }
         ],
         "xtype" : "Box"
        }
       ],
       "xtype" : "Popover"
      }
     ],
     "xtype" : "ScrolledWindow"
    }
   ],
   "xtype" : "Box",
   "| JsRender.JsRender getActiveFile" : [
    "() {",
    "    return this.main_window.windowstate.file;",
    "}",
    ""
   ],
   "| JsRender.Node? getActiveElement" : [
    " () { // return path to actie node.",
    "",
    "     var path = this.getActivePath();",
    "     if (path.length < 1) {",
    "        return null;",
    "     }",
    "     return _this.model.pathToNode(path);",
    "    ",
    "}",
    ""
   ],
   "| string getActivePath" : [
    " () {",
    "    ",
    "    var view = this.view.el;",
    "    if (view.get_selection().count_selected_rows() < 1) {",
    "        return \"\";",
    "    }",
    "    Gtk.TreeIter iter;",
    "    Gtk.TreeModel mod;",
    "    view.get_selection().get_selected(out mod, out iter);",
    "    return mod.get_path(iter).to_string();",
    "}",
    " "
   ],
   "| void onresize" : [
    "() {",
    " ",
    "\t ",
    "\t//GLib.debug(\"Got allocation width of scrolled view %d\", allocation.width );",
    "\t_this.maincol.el.set_max_width(",
    "\t \t_this.viewwin.el.get_width()  - 32",
    " \t);",
    "}",
    "",
    ""
   ]
  }
 ],
 "modOrder" : "",
 "name" : "WindowLeftTree",
 "parent" : "",
 "path" : "/home/alan/gitlive/roobuilder/src/Builder4/WindowLeftTree.bjs",
 "permname" : "",
 "title" : ""
}