{
 "name" : "WindowLeftTree",
 "parent" : "",
 "title" : "",
 "path" : "/home/alan/gitlive/roobuilder/src/Builder4/WindowLeftTree.bjs",
 "permname" : "",
 "modOrder" : "",
 "build_module" : "builder",
 "items" : [
  {
   "|           JsRender.Node? getActiveElement" : " () { // return path to actie node.\n\n     var path = this.getActivePath();\n     if (path.length < 1) {\n        return null;\n     }\n     return _this.model.pathToNode(path);\n     \n}\n",
   "@ bool before_node_change" : "()",
   "id" : "WindowLeftTree",
   "$ shadow_type" : "Gtk.ShadowType.IN",
   "* init" : " this.el.set_policy (Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC);\n \n",
   "|           JsRender.JsRender getActiveFile" : "() {\n    return this.main_window.windowstate.file;\n}\n",
   "* pack" : "add",
   "xtype" : "ScrolledWindow",
   "@ void changed" : "()",
   "$ xns" : "Gtk",
   "@ void node_selected" : "(JsRender.Node? node, string source)",
   "# Xcls_MainWindow main_window" : "null",
   "|           string getActivePath" : " () {\n    \n    var view = this.view.el;\n    if (view.get_selection().count_selected_rows() < 1) {\n        return \"\";\n    }\n    Gtk.TreeIter iter;\n    Gtk.TreeModel mod;\n    view.get_selection().get_selected(out mod, out iter);\n    return mod.get_path(iter).to_string();\n}\n ",
   "items" : [
    {
     "listeners" : {
      "button_release_event" : "(ev) => { \n    this.button_is_pressed = false;\n  return false;\n}",
      "button_press_event" : "  ( ev) => {\n    //console.log(\"button press?\");\n    this.button_is_pressed = true;\n    print(\"BUTTON DOWN\\n\");\n    \n    this.lastEventSource = \"tree\";\n    if (! _this.before_node_change() ) {\n    \n       return true;\n    }\n    \n\n    \n    if (ev.type != Gdk.EventType.BUTTON_PRESS  || ev.button != 3) {\n        //print(\"click\" + ev.type);\n        return false;\n    }\n    Gtk.TreePath res;\n    if (!_this.view.el.get_path_at_pos((int)ev.x,(int)ev.y, out res, null, null, null) ) {\n        return true;\n    }\n     \n    this.el.get_selection().select_path(res);\n     \n      //if (!this.get('/LeftTreeMenu').el)  { \n      //      this.get('/LeftTreeMenu').init(); \n      //  }\n        \n     _this.LeftTreeMenu.el.set_screen(Gdk.Screen.get_default());\n     _this.LeftTreeMenu.el.show_all();\n      _this.LeftTreeMenu.el.popup(null, null, null,  3, ev.time);\n     //   print(\"click:\" + res.path.to_string());\n      return true;\n}",
      "cursor_changed" : " ( ) => {\n    print(\"LEFT TREE Cursor Changed\\n\");\n\tif (!this.button_is_pressed && !this.key_is_pressed) {\n\t\t// then event was started by some other action\n\t\t// which should manually trigger all the events..\n\t\tprint(\"SKIPPING select - no button or key pressed\\n\");\n\t\treturn;\n\t}\n\n\n     if (this.blockChanges) { // probably not needed.. \n\t\tprint(\"SKIPPING select - blockchanges set..\\n\");     \n       return  ;\n     }\n      if (!_this.before_node_change( ) ) {\n\t     this.blockChanges = true;\n\t     this.el.get_selection().unselect_all();\n\t     this.blockChanges = false;\n\t     \n\t     return;\n     }\n     if (_this.main_window.windowstate.file == null) {\n   \t\tprint(\"SKIPPING select windowstate file is not set...\\n\");     \n         return;\n     } \n     \n     //var render = this.get('/LeftTree').getRenderer();                \n    print(\"LEFT TREE -> view -> selection changed called\\n\");\n    \n    \n    // -- it appears that the selection is not updated.\n      \n    GLib.Timeout.add_full(GLib.Priority.DEFAULT,10 , () => {\n         print(\"LEFT TREE -> view -> selection changed TIMEOUT CALLED\\n\");\n\n            if (this.el.get_selection().count_selected_rows() < 1) {\n\n                print(\"selected rows < 1\\n\");\n                //??this.model.load( false);\n                _this.node_selected(null, this.lastEventSource);\n                \n                return false ;\n            }\n                \n                //console.log('changed');\n            var s = this.el.get_selection();\n             Gtk.TreeIter iter;\n             Gtk.TreeModel mod;\n            s.get_selected(out mod, out iter);\n            \n            \n            // var val = \"\";\n            GLib.Value value;\n            _this.model.el.get_value(iter, 2, out value);\n            _this.model.activePath = mod.get_path(iter).to_string();\n            \n            var node = (JsRender.Node)value.dup_object();\n            print (\"calling left_tree.node_selected\\n\");\n            _this.node_selected(node, this.lastEventSource);\n            while (Gtk.events_pending()) {\n                Gtk.main_iteration();\n           }\n            var cp = mod.get_path(iter);\n            Gtk.TreePath sp, ep;\n            this.el.get_visible_range(out sp, out ep);\n            // if sp is before cp then retuns 1.\n            // if cp is before ep then retuns 1.\n            if (cp.compare(sp) >= 0 && ep.compare(cp) >=1) {\n                return false;\n            }\n            \n             \n            \n            this.el.scroll_to_cell(new Gtk.TreePath.from_string(_this.model.activePath), null, true, 0.1f,0.0f);\n            \n            return false;\n      });  \n    //_this.after_node_change(node);\n\n//        _this.model.file.changed(node, \"tree\");\n   \n    //Seed.print( value.get_string());\n    return  ;\n                \n}",
      "drag_begin" : "( ctx)  => {\n\t//print('SOURCE: drag-begin');\n        \n        \n        //this.targetData = \"\";\n        \n        // find what is selected in our tree...\n        \n        var s = _this.view.el.get_selection();\n        if (s.count_selected_rows() < 1) {\n            return;\n        }\n        Gtk.TreeIter iter;\n        Gtk.TreeModel mod;\n        s.get_selected(out mod, out iter);\n\n        \n\n        // set some properties of the tree for use by the dropped element.\n        GLib.Value value;\n        _this.model.el.get_value(iter, 2, out value);\n        var tp = mod.get_path(iter).to_string();\n        var data = (JsRender.Node)(value.dup_object());\n        var xname = data.fqn();\n        print (\"XNAME  IS \" + xname+ \"\\n\");\n        this.dragData = tp;\n        this.dropList = _this.main_window.windowstate.file.palete().getDropList(xname);\n        \n        print (\"DROP LIST IS \" + string.joinv(\", \", this.dropList) + \"\\n\");\n        \n\n        // make the drag icon a picture of the node that was selected\n    \n        \n    // by default returns the path..\n       var path = _this.model.el.get_path(iter);\n\n         \n        var pix = this.el.create_row_drag_icon ( path);\n        \n        Gtk.drag_set_icon_surface (ctx, pix) ;\n        \n        return;\n}",
      "drag_end" : "  (drag_context) => {\n\t//Seed.print('LEFT-TREE: drag-end');\n        this.dragData = \"\";\n        this.dropList = null;\n//        this.targetData = \"\";\n        this.highlightDropPath(\"\",0);\n//        return true;\n}",
      "drag_motion" : " ( ctx, x, y, time)  => {\n   print(\"got drag motion\\n\");\n    var src = Gtk.drag_get_source_widget(ctx);\n   this.drag_x = x;\n   this.drag_y = y;     \n\n   if (src != this.el) {\n   \n \n \n    // the point of this is to detect where an item could be dropped..\n        print(\"requesting drag data\\n\");\n       this.drag_in_motion = true;\n       \n            // request data that will be recieved by the recieve...              \n        Gtk.drag_get_data\n        (\n                this.el,         // will receive 'drag-data-received' signal \n                ctx,        // represents the current state of the DnD \n                Gdk.Atom.intern(\"STRING\",true),    // the target type we want \n                time            // time stamp \n        );\n        return true;\n  }    \n\n\n  print(\"action: %d\\n\", ctx.get_actions());\n //print(\"GETTING POS\");\n    var  targetData = \"\";\n\n    Gtk.TreePath path;\n    Gtk.TreeViewDropPosition pos;\n    var isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);\n\n    // if there are not items in the tree.. the we have to set isOver to true for anything..\n    var isEmpty = false;\n    if (_this.model.el.iter_n_children(null) < 1) {\n        print(\"got NO children?\\n\");\n        isOver = true; //??? \n        isEmpty = true;\n        pos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;\n    }\n\n\n    // ------------- a drag from self..\n\n\n    //var action = Gdk.DragAction.COPY;\n        // unless we are copying!!! ctl button..\n    \n    var action = (ctx.get_actions() & Gdk.DragAction.MOVE) > 0 ?\n                 Gdk.DragAction.COPY  : Gdk.DragAction.MOVE ;\n                // Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;\n\n\n    if (_this.model.el.iter_n_children(null) < 1) {\n        // no children.. -- asume it's ok..\n        \n        targetData = \"|%d|\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n           \n        this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);        \n        Gdk.drag_status(ctx, action ,time);\n        return true;\n        \n        // continue through to allow drop...\n\n    } \n        \n        \n\n    \n    \n    //print(\"ISOVER? \" + isOver);\n    if (!isOver) {\n  \n        Gdk.drag_status(ctx, 0 ,time);\n         this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);                    \n         return false;\n\n    }\n            \n    // drag node is parent of child..\n    //console.log(\"SRC TREEPATH: \" + src.treepath);\n    //console.log(\"TARGET TREEPATH: \" + data.path.to_string());\n    \n    // nned to check a  few here..\n    //Gtk.TreeViewDropPosition.INTO_OR_AFTER\n    //Gtk.TreeViewDropPosition.INTO_OR_BEFORE\n    //Gtk.TreeViewDropPosition.AFTER\n    //Gtk.TreeViewDropPosition.BEFORE\n    \n    // locally dragged items to not really use the \n    var selection_text = this.dragData;\n    \n            \n            \n    if (selection_text == null || selection_text.length < 1) {\n                //print(\"Error  - drag selection text returned NULL\");\n             Gdk.drag_status(ctx, 0 ,time);\n            this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);\n             return false;\n     }\n                       \n            \n            // see if we are dragging into ourself?\n    var target_path = path.to_string();            \n    print (\"Drag  %s onto %s--%d\\n \", selection_text, target_path, pos);\n    \n    // pos : 3 = ontop - 0 = after, 1 = before\n    //print(\"target_path=\"+target_path);\n\n    // \n    if (selection_text  == target_path) {\n        print(\"self drag ?? == we should perhaps allow copy onto self..\\n\");\n                \n         Gdk.drag_status(ctx, 0 ,time);\n          this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);\n          return false;\n//                 -- fixme -- this is not really correct..\n\n    }\n            \n    // check that \n    //print(\"DUMPING DATA\");\n    //console.dump(data);\n    // path, pos\n    \n    //print(data.path.to_string() +' => '+  data.pos);\n    \n    // dropList is a list of xtypes that this node could be dropped on.\n    // it is set up when we start to drag..\n    \n    \n    targetData = _this.model.findDropNodeByPath( path.to_string(), this.dropList, pos);\n        \n    print(\"targetDAta: \" + targetData +\"\\n\");\n    \n    if (targetData.length < 1) {\n        //print(\"Can not find drop node path\");\n       \n        Gdk.drag_status(ctx, 0, time);\n        this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);\n        return false;\n    }\n    \n    var td_ar = targetData.split(\"|\");\n      \n    \n\n    Gdk.drag_status(ctx, action ,time);\n    this.highlightDropPath(td_ar[0], (Gtk.TreeViewDropPosition)int.parse(td_ar[1]));\n    return true;\n       \n       \n}",
      "drag_data_get" : "( drag_context, data, info, time) => {\n            \n            \n                 //print(\"drag-data-get\");\n                 var s = this.el.get_selection();\n                 if (s.count_selected_rows() < 1) {\n                        data.set_text(\"\",0);     \n                         print(\"return empty string - no selection..\");\n                        return;\n                    }\n                 \n                 Gtk.TreeIter iter;\n                 Gtk.TreeModel mod;\n                 \n                 s.get_selected(out mod, out iter);\n                 \n                \n                \n                 GLib.Value value;\n                 _this.model.el.get_value(iter, 2, out value);\n                 var ndata = (JsRender.Node)(value.dup_object());\n                 \n                \n                \n                var tp = mod.get_path(iter).to_string();\n                // by default returns the path..\n                \n               if ( info != Gdk.Atom.intern(\"STRING\",true) ) {\n                    tp = ndata.toJsonString();\n               }   \n               \n               //data.set_text(tp,tp.length);   \n                \n                data.set (data.get_target (), 8, (uchar[]) tp.to_utf8 ());\n            \n                \n               //  print(\"return \" + tp);\n            }",
      "key_press_event" : "(ev) => {\n   this.key_is_pressed = true;\n    return false;\n}",
      "key_release_event" : "(ev) => {\n       this.key_is_pressed = false;\n      return false;\n}\n",
      "drag_data_received" : "  (ctx, x, y, sel, info, time)  => {\n  \n        // THIS CODE ONLY RELATES TO drag  or drop of \"NEW\" elements or \"FROM another tree..\"\n  \n  \n        //  print(\"Tree: drag-data-received\\n\");\n        var selection_text = (string)sel.get_data();\n        //print(\"selection_text= %s\\n\",selection_text);\n\n        var is_drag = this.drag_in_motion;\n    \n        \n\n\t\tGLib.debug(\"Is Drag %s\\n\", is_drag ? \"Y\": \"N\");\n        var  targetData = \"\";\n        \n        Gtk.TreePath path;\n        Gtk.TreeViewDropPosition pos;\n        var isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);\n        \n        // if there are not items in the tree.. the we have to set isOver to true for anything..\n        var isEmpty = false;\n        if (_this.model.el.iter_n_children(null) < 1) {\n            GLib.debug(\"got NO children?\\n\");\n            isOver = true; //??? \n            isEmpty = true;\n            pos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;\n        }\n        \n     \n        //console.log(\"LEFT-TREE: drag-motion\");\n        var src = Gtk.drag_get_source_widget(ctx);\n        \n        // a drag from self - this should be handled by drop and motion.\n        if (src == this.el) {\n            GLib.debug(\"Source == this element should not happen.. ? \\n\");\n            return;\n        }\n        //print(\"drag_data_recieved from another element\");\n        \n         \n        \n        \n        if (selection_text == null || selection_text.length < 1 || !isOver) {\n            // nothing valid foudn to drop...\n               GLib.debug(\"empty sel text or not over\");\n            if (is_drag) {\n                Gdk.drag_status(ctx, 0, time);\n                this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);\n                return;\n            }\n            Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n            // no drop action...\n            return;            \n        \n        }\n        var dropNode = new JsRender.Node(); \n        \n        var dropNodeType  = selection_text;\n        var show_templates = true;\n        // for drop\n        if (dropNodeType[0] == '{') {\n            var pa = new Json.Parser();\n            try {\n                pa.load_from_data(dropNodeType);\n            } catch (Error e) {\n                Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n                // no drop action...\n                return;   \n            }\n             \n            dropNode.loadFromJson( pa.get_root().get_object(), 2);\n            dropNodeType = dropNode.fqn();\n            show_templates = false;\n            \n            \n        } else {\n        \tif (selection_text.contains(\":\")) {\n\t        \tvar bits = selection_text.split(\":\");\n\t            dropNode.setFqn(bits[0]);\n\t            dropNode.props.set(\"* prop\", bits[1]);\n        \t} else {\n\n\t            dropNode.setFqn(selection_text);\n            }\n        }\n\n         \n        // dropList --- need to gather this ... \n        GLib.debug(\"get dropList for : %s\\n\",dropNodeType);            \n        var dropList = _this.main_window.windowstate.file.palete().getDropList(dropNodeType);\n        \n        GLib.debug(\"dropList: %s\\n\", string.joinv(\" , \", dropList));\n        \n        // if drag action is link ... then we can drop it anywahere...\n         if ((ctx.get_actions() & Gdk.DragAction.LINK) > 0) {\n             // if path is null?? dragging into an empty tree?\n             targetData = (path == null ? \"\" :  path.to_string()) + \"|%d\".printf((int)pos);\n         } else {\n        \n        \n            targetData = _this.model.findDropNodeByPath( isEmpty ? \"\" : path.to_string(), dropList, pos);\n         }\n        \n        \n            \n        GLib.debug(\"targetDAta: %s\", targetData );\n        \n        if (targetData.length < 1) {\n         \n            // invalid drop path..\n            if (this.drag_in_motion) {\n                Gdk.drag_status(ctx, 0, time);\n                this.highlightDropPath(\"\", (Gtk.TreeViewDropPosition)0);\n                return;\n            }\n            Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n            // no drop action...\n            return;\n        }\n        \n        \n        \n         var td_ar = targetData.split(\"|\");\n          \n        \n        if (this.drag_in_motion) { \n            Gdk.drag_status(ctx, Gdk.DragAction.COPY ,time);\n\n            this.highlightDropPath(  td_ar[0]  , (Gtk.TreeViewDropPosition)int.parse(td_ar[1]));\n            return;\n        }\n        // continue on to allow drop..\n    \n\n        // at this point, drag is not in motion... -- as checked above... - so it's a real drop event..\n        //targetData\n  \t\t//   {parent}|{pos}|{prop}\n  \n\n        _this.model.dropNode(targetData, dropNode, show_templates);\n        GLib.debug(\"ADD new node!!!\\n\");\n            \n        ///Xcls_DialogTemplateSelect.singleton().show( _this.model.file.palete(), node);\n        \n        Gtk.drag_finish (ctx, false, false,time);\n        \n        \n            \n            \n      \n}",
      "drag_drop" : " (  ctx, x, y, time)  => {\n      //Seed.print(\"TARGET: drag-drop\");\n   \n   \n    var src = Gtk.drag_get_source_widget(ctx);\n     \n   if (src != this.el) {\n   \n    \n       \n       this.drag_in_motion = false;   \n            // request data that will be recieved by the recieve...              \n        Gtk.drag_get_data\n        (\n                this.el,         // will receive 'drag-data-received' signal \n                ctx,        // represents the current state of the DnD \n                Gdk.Atom.intern(\"application/json\",true),    // the target type we want \n                time            // time stamp \n        );\n\n         \n        // No target offered by source => error\n   \n\n         return  false;\n     }\n     \n     // handle drop around self..\n     \n                  \n            \n    //print(\"GETTING POS\");\n    var  targetData = \"\";\n    \n    Gtk.TreePath path;\n    Gtk.TreeViewDropPosition pos;\n    var isOver = _this.view.el.get_dest_row_at_pos(this.drag_x,this.drag_y, out path, out pos);\n    \n    // if there are not items in the tree.. the we have to set isOver to true for anything..\n    var isEmpty = false;\n    if (_this.model.el.iter_n_children(null) < 1) {\n        print(\"got NO children?\\n\");\n        isOver = true; //??? \n        isEmpty = true;\n        pos = Gtk.TreeViewDropPosition.INTO_OR_AFTER;\n    }\n    \n     \n     \n    //var action = Gdk.DragAction.COPY;\n        // unless we are copying!!! ctl button..\n    \n    var action = (ctx.get_actions() & Gdk.DragAction.MOVE) > 0 ?\n                 Gdk.DragAction.COPY  : Gdk.DragAction.MOVE ;\n                // Gdk.DragAction.MOVE : Gdk.DragAction.COPY ;\n\n      \n    if (_this.model.el.iter_n_children(null) < 1) {\n        // no children.. -- asume it's ok..\n        \n        targetData = \"|%d|\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n         \n        // continue through to allow drop...\n\n    } else {\n                \n                \n    \n                \n                \n                //print(\"ISOVER? \" + isOver);\n        if (!isOver) {\n            \n            Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n            return true; // not over apoint!?! - no action on drop or motion..\n        }\n                \n        // drag node is parent of child..\n        //console.log(\"SRC TREEPATH: \" + src.treepath);\n        //console.log(\"TARGET TREEPATH: \" + data.path.to_string());\n        \n        // nned to check a  few here..\n        //Gtk.TreeViewDropPosition.INTO_OR_AFTER\n        //Gtk.TreeViewDropPosition.INTO_OR_BEFORE\n        //Gtk.TreeViewDropPosition.AFTER\n        //Gtk.TreeViewDropPosition.BEFORE\n        \n        // locally dragged items to not really use the \n        var selection_text = this.dragData;\n        \n        \n        \n        if (selection_text == null || selection_text.length < 1) {\n            //print(\"Error  - drag selection text returned NULL\");\n          \n             Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n             return true; /// -- fixme -- this is not really correct..\n        }                \n                \n                // see if we are dragging into ourself?\n                print (\"got selection text of  \" + selection_text);\n        \n        var target_path = path.to_string();\n        //print(\"target_path=\"+target_path);\n\n        // \n        if (selection_text  == target_path) {\n            print(\"self drag ?? == we should perhaps allow copy onto self..\\n\");\n            \n             Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n\n             return true; /// -- fixme -- this is not really correct..\n\n        }\n                \n        // check that \n        //print(\"DUMPING DATA\");\n        //console.dump(data);\n        // path, pos\n        \n        //print(data.path.to_string() +' => '+  data.pos);\n        \n        // dropList is a list of xtypes that this node could be dropped on.\n        // it is set up when we start to drag..\n        \n        \n        targetData = _this.model.findDropNodeByPath( path.to_string(), this.dropList, pos);\n            \n        print(\"targetDAta: \" + targetData +\"\\n\");\n        \n        if (targetData.length < 1) {\n            //print(\"Can not find drop node path\");\n             \n            Gtk.drag_finish (ctx, false, false, time);        // drop failed..\n            return true;\n        }\n                    \n                \n                \n                // continue on to allow drop..\n  }\n        // at this point, drag is not in motion... -- as checked above... - so it's a real drop event..\n\n\n     var delete_selection_data = false;\n        \n    if (action == Gdk.DragAction.ASK)  {\n        /* Ask the user to move or copy, then set the ctx action. */\n    }\n\n    if (action == Gdk.DragAction.MOVE) {\n        delete_selection_data = true;\n    }\n      \n                // drag around.. - reorder..\n    _this.model.moveNode(targetData, action);\n        \n       \n        \n        \n        \n        // we can send stuff to souce here...\n\n\n// do we always say failure, so we handle the reall drop?\n    Gtk.drag_finish (ctx, false, false,time); //delete_selection_data, time);\n\n    return true;\n \n \n \n \n \n \n}"
     },
     "# string dragData" : "",
     "# string[] dropList" : "",
     "# int drag_x" : "",
     "id" : "view",
     "gboolean headers_visible" : true,
     "# int drag_y" : "",
     "* init" : "{\n    var description = new Pango.FontDescription();\n    description.set_size(8000);\n    this.el.override_font(description);\n\n    var selection = this.el.get_selection();\n    selection.set_mode( Gtk.SelectionMode.SINGLE);\n\n\n    // is this really needed??\n    /*\n    this.selection.signal['changed'].connect(function() {\n\t    _this.get('/LeftTree.view').listeners.cursor_changed.apply(\n\t        _this.get('/LeftTree.view'), [ _this.get('/LeftTree.view'), '']\n\t    );\n    });\n    */\n    Gtk.drag_source_set (\n\t    this.el,            /* widget will be drag-able */\n\t    Gdk.ModifierType.BUTTON1_MASK,       /* modifier that will start a drag */\n\t    BuilderApplication.targetList,            /* lists of target to support */\n\t    Gdk.DragAction.COPY   | Gdk.DragAction.MOVE    |  Gdk.DragAction.LINK           /* what to do with data after dropped */\n    );\n\n    // ?? needed??\n    //Gtk.drag_source_add_text_targets(this.el); \n\n    Gtk.drag_dest_set\n    (\n        this.el,              /* widget that will accept a drop */\n        Gtk.DestDefaults.MOTION  | Gtk.DestDefaults.HIGHLIGHT,\n        BuilderApplication.targetList,            /* lists of target to support */\n        Gdk.DragAction.COPY   | Gdk.DragAction.MOVE   | Gdk.DragAction.LINK     /* what to do with data after dropped */\n    );\n\n    //Gtk.drag_dest_set_target_list(this.el, Builder.Application.targetList);\n    //Gtk.drag_dest_add_text_targets(this.el);\n}\n",
     "tooltip_column" : 1,
     "bool expand" : true,
     "* pack" : "add",
     "xtype" : "TreeView",
     "$ enable_tree_lines" : true,
     "$ headers_visible" : false,
     "bool button_is_pressed" : false,
     "|           void highlightDropPath" : " ( string treepath, Gtk.TreeViewDropPosition pos) {\n\n        // highlighting for drag/drop\n        if (treepath.length > 0) {\n            this.el.set_drag_dest_row(  new  Gtk.TreePath.from_string( treepath ), pos);\n          } else {\n            this.el.set_drag_dest_row(null, Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n         }\n             \n}",
     "$ string lastEventSource" : "\"\"",
     "bool key_is_pressed" : false,
     "# bool drag_in_motion" : "",
     "# bool blockChanges" : false,
     "$ xns" : "Gtk",
     "| void setCursor" : "(string treepath, string sourceEvent)   {\n\tthis.lastEventSource = sourceEvent;\n\t//this.blockChanges = true; << block changes prevents loading of 'node data' and firing of node_selected..\n    this.el.set_cursor(new Gtk.TreePath.from_string(treepath), null, false); \n    // fire node_selected..\n    //this.blockChanges = false;\n\tthis.lastEventSource = \"\";\n}\n",
     "|           void selectNode" : "(string treepath_str, string source) {\n\tthis.lastEventSource = source;\n    //this.selection.select_path(new  Gtk.TreePath.from_string( treepath_str));\n     var tp = new Gtk.TreePath.from_string(treepath_str);\n     \n     this.el.set_cursor(tp, null, false);  \n     this.el.scroll_to_cell(tp, null, false, 0,0);\n}\n",
     "items" : [
      {
       "|           string findDropNode" : " (string treepath_str, string[] targets) {\n\n    // this is used by the dragdrop code in the roo version AFAIR..\n\n    //var path = treepath_str.replace(/^builder-/, '');\n    // treemap is depreciated... - should really check if model has any entries..\n\n    if (this.el.iter_n_children(null) < 1) {\n        //print(\"NO KEYS\");\n        return \"|%d\".printf((int)Gtk.TreeViewDropPosition.INTO_OR_AFTER);\n    }\n    //print(\"FIND treepath: \" + path);\n    //console.dump(this.treemap);\n    \n    //if (!treepath_str.match(/^builder-/)) {\n    //    return []; // nothing!\n    //}\n    if (targets.length > 0 && targets[0] == \"*\") {\n        return  treepath_str;\n    }\n    return this.findDropNodeByPath(treepath_str,targets, -1);\n}\n",
       "id" : "model",
       "currentTree" : false,
       "# DialogTemplateSelect template_select" : "null",
       "* init" : "print(\"model initialized\");\n\n",
       "|           void loadFile" : "(JsRender.JsRender f) {\n    //console.dump(f);\n    this.el.clear();\n    \n    // needed???\n    _this.main_window.windowstate.file = f;\n    \n   \n    if (f.tree == null) {\n\t    try {\n\t        f.loadItems( );\n        } catch (Error e) {\n    \t\treturn;\n        }\n    }\n    // if it's still null?\n    if (f.tree == null) {\n        return;\n    }\n  \n    var o = new Gee.ArrayList<JsRender.Node>();\n    o.add(f.tree);\n    this.load(o,null);\n    \n    _this.view.el.expand_all();\n\n    if (f.tree.items.size < 1) {\n        // single item..\n        \n        //this.get('/Window.leftvpaned').el.set_position(80);\n        // select first...\n        _this.view.el.set_cursor( \n            new  Gtk.TreePath.from_string(\"0\"), null, false);\n        \n        \n    } else {\n          //this.get('/Window.leftvpaned').el.set_position(200);\n    }\n    \n    return;\n \n            \n}\n",
       "|    void updateSelected" : "() {\n  \n   \n    var s = _this.view.el.get_selection();\n    \n     Gtk.TreeIter iter;\n    Gtk.TreeModel mod;\n    \n    \n    \n    if (!s.get_selected(out mod, out iter)) {\n        return; // nothing seleted..\n    }\n  \n  GLib.Value value;\n    this.el.get_value(iter, 2, out value);\n    var node = (JsRender.Node)(value.get_object());\n    \n      this.el.set(iter, 0, node.nodeTitle(),\n                1, node.nodeTip(), -1\n        );\n}\n",
       "* pack" : "set_model",
       "xtype" : "TreeStore",
       "|           string findDropNodeByPath" : " (string treepath_str, string[] targets, int in_pref = -1) {\n\n    var path = treepath_str; // dupe it..\n    \n    \n    // pref : 3 = ontop - 0 = after, 1 = before\n    int pref = in_pref < 0  ?  Gtk.TreeViewDropPosition.INTO_OR_AFTER : in_pref;\n    \n    var last = \"\";\n    \n    //console.dump(this.treemap);\n    \n    print(\"findDropNodeByPath : got path length %d / %s\\n\", path.length, path);\n    \n    if (path.length == 0) {\n        // top drop. // just return empty..\n        return \"|%d\".printf((int)pref) ;\n        \n    }\n    \n    \n    while (path.length > 0) {\n    \n        if (path.length == treepath_str.length && pref != Gtk.TreeViewDropPosition.INTO_OR_AFTER) {\n            if (path.last_index_of(\":\") < 0 ) {\n                return \"\";\n            }\n            path = path.substring(0, path.last_index_of(\":\"));\n            last = treepath_str;\n            print(\"DROP  before or after : using %s\\n\",path);\n            continue;\n        }\n    \n        //print(\"LOOKING FOR PATH: \" + path);\n        var node_data = this.pathToNode(path);\n        \n        if (node_data == null) {\n            print(\"node not found\");\n            return \"\";\n        }\n        \n        var xname = node_data.fqn();\n        var match = \"\";\n        var prop = \"\";\n        \n        for (var i =0; i < targets.length; i++)  {\n            var tg = targets[i];\n            if ((tg == xname)  ) {\n                match = tg;\n                break;\n            }\n            // if target is \"xxxx:name\"\n            if (tg.contains(xname +\":\")) {\n                match = tg;\n                var ar = tg.split(\":\");\n                prop = ar[1];\n                break;\n            }\n        }\n        \n        if (match.length > 0) {\n            if (last.length > 0) { // pref is after/before..\n                // then it's after last\n                //if (pref > 1) {\n                //    return \"\";\n                //}\n                return last + \"|%d\".printf((int)pref) + \"|\" + prop;\n\n                \n            }\n            // we need to add prop - as :store -> needs to bee added when dropping onto.\n            return path + \"|%d\".printf( (int) Gtk.TreeViewDropPosition.INTO_OR_AFTER)  + \"|\" + prop;\n        }\n        /*\n        last = \"\" + path;\n        var par = path.split(\":\");\n        string [] ppar = {};\n        for (var i = 0; i < par.length-1; i++) {\n            ppar += par[i];\n        }\n        \n        path = string.joinv(\":\", ppar);\n        */\n        break;\n\n    }\n    \n    return \"\";\n            \n}\n",
       "|           void moveNode" : "(string target_data, Gdk.DragAction action) \n{\n   \n   /// target_data = \"path|pos\");\n   \n   \n    //print(\"MOVE NODE\");\n    // console.dump(target_data);\n    Gtk.TreeIter old_iter;\n    Gtk.TreeModel mod;\n    \n    var s = _this.view.el.get_selection();\n    s.get_selected(out mod , out old_iter);\n    mod.get_path(old_iter);\n    \n    var node = this.pathToNode(mod.get_path(old_iter).to_string());\n    //console.dump(node);\n    if (node == null) {\n        print(\"moveNode: ERROR - node is null?\");\n    }\n    \n    \n\n    // needs to drop first, otherwise the target_data \n    // treepath will be invalid.\n\n    \n    if ((action & Gdk.DragAction.MOVE) > 0) {\n            print(\"REMOVING OLD NODE : \" + target_data + \"\\n\");\n            node.remove();\n            this.dropNode(target_data, node, false);\n            this.el.remove(ref old_iter);\n            \n            \n                         \n    } else {\n        print(\"DROPPING NODE // copy: \" + target_data + \"\\n\");\n        node = node.deepClone();\n        this.dropNode(target_data, node, false);\n    }\n    _this.changed();\n    this.activePath= \"\";\n    //this.updateNode(false,true);\n}\n",
       "# string activePath" : "\"\"",
       "$ columns" : "typeof(string),typeof(string),typeof(Object)",
       "|           void load" : "(Gee.ArrayList<JsRender.Node> tr, Gtk.TreeIter? iter) \n{\n    Gtk.TreeIter citer;\n    //this.insert(citer,iter,0);\n    for(var i =0 ; i < tr.size; i++) {\n        if (iter != null) {\n            this.el.insert(out citer,iter,-1); // why not append?\n        } else {\n            this.el.append(out citer,null);\n        }\n        \n        this.el.set(citer, 0, tr.get(i).nodeTitle(),\n                1, tr.get(i).nodeTip(), -1\n        );\n        var o =   GLib.Value(typeof(Object));\n        o.set_object((Object)tr.get(i));\n        \n        this.el.set_value(citer, 2, o);\n        \n        if (tr.get(i).items.size > 0) {\n            this.load(tr.get(i).items, citer);\n        }\n     \n    }\n\n    \n}",
       "|           void deleteSelected" : "() {\n    \n    print(\"DELETE SELECTED?\");\n    //_this.view.blockChanges = true;\n    print(\"GET SELECTION?\");\n\n    var s = _this.view.el.get_selection();\n    \n    print(\"GET  SELECTED?\");\n   Gtk.TreeIter iter;\n    Gtk.TreeModel mod;\n\n    \n    if (!s.get_selected(out mod, out iter)) {\n        return; // nothing seleted..\n    }\n      \n\n\n    this.activePath= \"\";      \n    print(\"GET  vnode value?\");\n\n    GLib.Value value;\n    this.el.get_value(iter, 2, out value);\n    var data = (JsRender.Node)(value.get_object());\n    print(\"removing node from Render\\n\");\n    if (data.parent == null) {\n       _this.main_window.windowstate.file.tree = null;\n    } else {\n        data.remove();\n    }\n    print(\"removing node from Tree\\n\");    \n    s.unselect_all();\n    this.el.remove(ref iter);\n\n    \n    \n    \n    // \n    \n    \n\n\n    this.activePath= \"\"; // again!?!?      \n    //this.changed(null,true);\n    \n    _this.changed();\n    \n    _this.view.blockChanges = false;\n}\n",
       "n_columns" : 3,
       "$ xns" : "Gtk",
       "|           JsRender.Node pathToNode" : "(string path) {\n \n     \n     Gtk.TreeIter   iter;\n     _this.model.el.get_iter_from_string(out iter, path);\n     \n     GLib.Value value;\n     _this.model.el.get_value(iter, 2, out value);\n     \n     return (JsRender.Node)value.dup_object();\n\n}",
       "|           void dropNode" : "(string target_data_str, JsRender.Node node, bool show_templates) {\n//         print(\"drop Node\");\n     // console.dump(node);\n  //    console.dump(target_data);\n  \n  \t\t//target_data_str\n  \t\t//   {parent}|{pos}|{prop}\n  \n  \n        // 0 = before , 1=after 2/3 onto\n  \n  \t\tGLib.debug(\"dropNode %s\", target_data_str);\n        var target_data= target_data_str.split(\"|\");\n  \n        var parent_str = target_data[0].length > 0 ? target_data[0] : \"\";\n        var pos = target_data.length > 1 ? int.parse(target_data[1]) : 2; // ontop..\n  \n  \n        Gtk.TreePath tree_path  =   parent_str.length > 0 ? new  Gtk.TreePath.from_string( parent_str ) : null;\n        \n        \n        \n        //print(\"add \" + tp + \"@\" + target_data[1]  );\n        \n        JsRender.Node parentNode = null;\n        \n        Gtk.TreeIter iter_after;\n        Gtk.TreeIter iter_par ;\n        \n       \n         if (target_data.length == 3 && target_data[2].length > 0) {\n            node.props.set(\"* prop\", target_data[2]);\n        }\n\n        Gtk.TreePath expand_parent = null;\n        \n        // we only need to show the template if it's come from else where?\n         if (show_templates) {\n         \n             var ts = _this.main_window.windowstate.template_select;\n         \n             var new_node = ts.show(\n                  _this.main_window, // (Gtk.Window) _this.el.get_toplevel (),\n                 _this.main_window.windowstate.file.palete(),\n                    node,\n                    _this.main_window.windowstate.project);\n                   \n             if (new_node == null) {\n                 return; // do not add?\n             }\n             node = new_node;\n        }        \n        \n         //print(\"pos is %d  \\n\".printf(pos));\n        \n         Gtk.TreeIter n_iter; \n         \n         if ( parent_str.length < 1) {\n              this.el.append(out n_iter, null); // drop at top level..\n              node.parent = null;\n              _this.main_window.windowstate.file.tree = node;\n              \n              \n        } else   if (pos  < 2) {\n            //print(target_data[1]  > 0 ? 'insert_after' : 'insert_before');\n            \n            this.el.get_iter(out iter_after, tree_path );            \n            this.el.iter_parent(out iter_par, iter_after);\n            expand_parent = this.el.get_path(iter_par);\n            \n            GLib.Value value;\n            this.el.get_value( iter_par, 2, out value);\n            parentNode =  (JsRender.Node)value.dup_object();\n            \n            \n            this.el.get_value( iter_after, 2, out value);\n            var relNode =  (JsRender.Node)value.dup_object();\n            \n            if ( pos  > 0 ) {\n             \n                this.el.insert_after(out n_iter,    iter_par  , iter_after);\n                var ix = parentNode.items.index_of(relNode);\n                parentNode.items.insert(ix+1, node);\n                \n            } else {\n                this.el.insert_before(out n_iter,  iter_par  , iter_after);\n                var ix = parentNode.items.index_of(relNode);\n                parentNode.items.insert(ix, node);\n \n            }\n            node.parent = parentNode;\n            \n            \n            \n        } else {\n           //  print(\"appending to  \" + parent_str);\n            this.el.get_iter(out iter_par, tree_path);\n            this.el.append(out n_iter,   iter_par );\n            expand_parent = this.el.get_path(iter_par);\n            \n            GLib.Value value;\n            this.el.get_value( iter_par, 2, out value);\n            parentNode =  (JsRender.Node)value.dup_object();\n            node.parent = parentNode;\n            parentNode.items.add(node);\n        }\n        \n        // reparent node in tree...\n       \n        \n        // why only on no parent???\n        \n        //if (node.parent = null) {\n             \n           \n            \n        //}\n        \n        \n        // work out what kind of packing to use.. -- should be in \n        if (!node.has(\"pack\")   && parent_str.length > 1) {\n            \n            _this.main_window.windowstate.file.palete().fillPack(node,parentNode);\n            \n            \n        }\n        \n        // add the node...\n        \n        this.el.set(n_iter, 0, node.nodeTitle(), 1, node.nodeTip(), -1  );\n        var o =   GLib.Value(typeof(Object));\n        o.set_object((Object)node);\n        \n        this.el.set_value(n_iter, 2, o);\n        \n        \n        \n        \n// load children - if it has any..\n      \n        if (node.items.size > 0) {\n            this.load(node.items, n_iter);\n            _this.view.el.expand_row(this.el.get_path(n_iter), true);\n        } else if (expand_parent != null && !_this.view.el.is_row_expanded(expand_parent)) {\n           _this.view.el.expand_row(expand_parent,true);\n        }\n\n        //if (tp != null && (node.items.length() > 0 || pos > 1)) {\n        //    _this.view.el.expand_row(this.el.get_path(iter_par), true);\n       // }\n        // wee need to get the empty proptypes from somewhere..\n        \n        //var olditer = this.activeIter;\n        this.activePath = this.el.get_path(n_iter).to_string();\n\n\n        // pretend button was pressed, so that we can trigger select node...\n        _this.view.button_is_pressed = true;\n        _this.view.lastEventSource = \"\";\n        _this.view.el.set_cursor(this.el.get_path(n_iter), null, false);\n        _this.view.button_is_pressed = false;\n        _this.changed();\n     \n        \n            \n}\n",
       "$ listAllTypes" : "function() {\n    var s = this.get('/LeftTree.view').selection;\n    print (\"LIST ALL TYPES: \" + s.count_selected_rows() );\n    \n    if (s.count_selected_rows() > 0) {\n        var iter = new Gtk.TreeIter();    \n        s.get_selected(this.el, iter);\n\n        // set some properties of the tree for use by the dropped element.\n        var value = new GObject.Value('');\n        this.el.get_value(iter, 2, value);\n        var data = JSON.parse(value.value);\n        \n        \n        var xname = this.get('/LeftTree.model').file.guessName(data);\n        console.log('selected:' + xname);\n        if (xname.length) {\n            return [ xname ];\n        }\n        return []; // could not find it..\n    }\n    \n    var ret = [ ];\n    \n   var _this = this;\n    function addall(li)\n    {\n        li.forEach(function(el) {\n            // this is specific to roo!!!?\n            if (!el) { // skip empty?\n                return;\n            }\n            var fullpath =  _this.file.guessName(el);\n            if (fullpath.length && ret.indexOf(fullpath) < 0) {\n                ret.push(fullpath);\n            }\n            \n            \n            if (el.items && el.items.length) {\n                addall(el.items);\n            }\n            \n        });\n        \n        \n    }\n    \n    addall([this.currentTree]);\n    \n    // only if we have nothing, should we add '*top'\n    if (!ret.length) {\n        ret = [ '*top' ];\n    }\n    //console.log('all types in tree');\n    //console.dump(ret);\n    \n    return ret;\n                            \n}\n",
       "| string treePathFromNode" : "(JsRender.Node node) {\n    // iterate through the tree and find the node\n    var ret = \"\";\n    \n    this.el.foreach((mod, pth, iter) => {\n        // get the node..\n      \n     \n         GLib.Value value;\n         _this.model.el.get_value(iter, 2, out value);\n         \n\n         \n         var n = (JsRender.Node)value;\n\n         print(\"compare %s to %s\\n\", n.fqn(), node.fqn());\n        if (node == n) {\n            ret = pth.to_string();\n            return true;\n        }\n        return false;\n    });\n    return ret;\n\n}\n"
      },
      {
       "utf8 title" : "test",
       "* init" : "  this.el.add_attribute(_this.renderer.el , \"markup\", 0 );\n ",
       "xtype" : "TreeViewColumn",
       "* pack" : "append_column",
       "$ xns" : "Gtk",
       "items" : [
        {
         "id" : "renderer",
         "* pack" : "pack_start,true",
         "xtype" : "CellRendererText",
         "$ xns" : "Gtk"
        }
       ]
      }
     ]
    },
    {
     "id" : "LeftTreeMenu",
     "* pack" : false,
     "xtype" : "Menu",
     "$ xns" : "Gtk",
     "items" : [
      {
       "listeners" : {
        "activate" : "  ( ) => {\n    \n    print(\"ACTIVATE?\");\n    \n  \n     _this.model.deleteSelected();\n}"
       },
       "label" : "Delete Element",
       "* pack" : "add",
       "xtype" : "MenuItem",
       "$ xns" : "Gtk"
      },
      {
       "listeners" : {
        "activate" : "  () => {\n\n     DialogSaveTemplate.singleton().show(\n            (Gtk.Window) _this.el.get_toplevel (), \n            _this.main_window.windowstate.file.palete(), \n            _this.getActiveElement()\n    );\n     \n    \n}"
       },
       "label" : "Save as Template",
       "* pack" : "add",
       "xtype" : "MenuItem",
       "$ xns" : "Gtk"
      },
      {
       "listeners" : {
        "activate" : "  () => {\n    var node = _this.getActiveElement();\n     var name = DialogSaveModule.singleton().show(\n            (Gtk.Window) _this.el.get_toplevel (), \n            _this.main_window.windowstate.project, \n            node\n     );\n     if (name.length < 1) {\n            return;\n  \n     }\n     node.props.set(\"* xinclude\", name);\n     node.items.clear();\n\n\n    var s = _this.view.el.get_selection();\n    \n    print(\"GET  SELECTED?\");\n    Gtk.TreeIter iter;\n    Gtk.TreeModel mod;\n\n    \n    if (!s.get_selected(out mod, out iter)) {\n        return; // nothing seleted..\n    }\n    Gtk.TreeIter citer;\n    var n_cn = mod.iter_n_children(iter) -1;\n    for (var i = n_cn; i > -1; i--) {\n        mod.iter_nth_child(out citer, iter, i);\n        \n\n        print(\"removing node from Tree\\n\");    \n    \n        _this.model.el.remove(ref citer);\n    }\n    _this.changed();\n    _this.node_selected(node, \"tree\");\n     \n    \n}"
       },
       "label" : "Save as Module",
       "* pack" : "add",
       "xtype" : "MenuItem",
       "$ xns" : "Gtk"
      }
     ]
    }
   ]
  }
 ]
}