/* Spawn.vala.c generated by valac, the Vala compiler
 * generated from Spawn.vala, do not modify */

/*/ # valac  --pkg gio-2.0    --pkg posix Spawn.vala -o /tmp/Spawn*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_SPAWN (spawn_get_type ())
#define SPAWN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SPAWN, Spawn))
#define SPAWN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SPAWN, SpawnClass))
#define IS_SPAWN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SPAWN))
#define IS_SPAWN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SPAWN))
#define SPAWN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SPAWN, SpawnClass))

typedef struct _Spawn Spawn;
typedef struct _SpawnClass SpawnClass;
typedef struct _SpawnPrivate SpawnPrivate;
enum  {
	SPAWN_0_PROPERTY,
	SPAWN_NUM_PROPERTIES
};
static GParamSpec* spawn_properties[SPAWN_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	SPAWN_INPUT_SIGNAL,
	SPAWN_COMPLETE_SIGNAL,
	SPAWN_OUTPUT_LINE_SIGNAL,
	SPAWN_NUM_SIGNALS
};
static guint spawn_signals[SPAWN_NUM_SIGNALS] = {0};

/**
 * Revised version?
 * 
 * x = new Spawn( "/tmp", {"ls", "-l" })
 * 
 * // these are optionall..
 * x.env = ..... (if you need to set one...
 * x.output_line.connect((string str) => { 
 * 		if ( Gtk.events_pending()) { Gtk.main_iteration(); } 
 * });
 * x.input_line.connect(() => { return string });
 * 
 * x.run((int res, string output, string stderr) => { ... });

 * 
 * 
 */
typedef enum  {
	SPAWN_ERROR_NO_ARGS,
	SPAWN_ERROR_WRITE_ERROR,
	SPAWN_ERROR_EXECUTE_ERROR
} SpawnError;
#define SPAWN_ERROR spawn_error_quark ()
struct _Spawn {
	GObject parent_instance;
	SpawnPrivate * priv;
	gchar* cwd;
	gchar** args;
	gint args_length1;
	gchar** env;
	gint env_length1;
	gboolean is_async;
	gboolean throw_exceptions;
	gboolean detach;
	gchar* output;
	gchar* stderr;
	gint result;
};

struct _SpawnClass {
	GObjectClass parent_class;
};

struct _SpawnPrivate {
	GMainLoop* ctx;
	gint pid;
	GIOChannel* in_ch;
	GIOChannel* out_ch;
	GIOChannel* err_ch;
	gint err_src;
	gint out_src;
};

static gint Spawn_private_offset;
static gpointer spawn_parent_class = NULL;

VALA_EXTERN GQuark spawn_error_quark (void);
VALA_EXTERN GType spawn_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Spawn, g_object_unref)
VALA_EXTERN Spawn* spawn_new (const gchar* cwd,
                  gchar** args,
                  gint args_length1,
                  GError** error);
VALA_EXTERN Spawn* spawn_construct (GType object_type,
                        const gchar* cwd,
                        gchar** args,
                        gint args_length1,
                        GError** error);
static gchar** _vala_array_dup13 (gchar** self,
                           gssize length);
VALA_EXTERN void spawn_run (Spawn* self,
                GError** error);
static void ___lambda33_ (Spawn* self,
                   GPid pid,
                   gint status);
static void ____lambda33__gchild_watch_func (GPid pid,
                                      gint wait_status,
                                      gpointer self);
static void __lambda34_ (Spawn* self,
                  GPid w_pid,
                  gint _result_);
static gboolean spawn_read (Spawn* self,
                     GIOChannel* ch);
static void spawn_tidyup (Spawn* self);
static void ___lambda34__gchild_watch_func (GPid pid,
                                     gint wait_status,
                                     gpointer self);
static gboolean __lambda35_ (Spawn* self,
                      GIOChannel* channel,
                      GIOCondition condition);
static gboolean ___lambda35__gio_func (GIOChannel* source,
                                GIOCondition condition,
                                gpointer self);
static gboolean __lambda36_ (Spawn* self,
                      GIOChannel* channel,
                      GIOCondition condition);
static gboolean ___lambda36__gio_func (GIOChannel* source,
                                GIOCondition condition,
                                gpointer self);
static gint spawn_write (Spawn* self,
                  const gchar* str,
                  GError** error);
static void g_cclosure_user_marshal_STRING__VOID (GClosure * closure,
                                           GValue * return_value,
                                           guint n_param_values,
                                           const GValue * param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__INT_STRING_STRING (GClosure * closure,
                                                      GValue * return_value,
                                                      guint n_param_values,
                                                      const GValue * param_values,
                                                      gpointer invocation_hint,
                                                      gpointer marshal_data);
static void spawn_finalize (GObject * obj);
static GType spawn_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static inline gpointer _vala_memdup2 (gconstpointer mem,
                        gsize byte_size);

GQuark
spawn_error_quark (void)
{
	return g_quark_from_static_string ("spawn-error-quark");
}

static inline gpointer
spawn_get_instance_private (Spawn* self)
{
	return G_STRUCT_MEMBER_P (self, Spawn_private_offset);
}

static gchar**
_vala_array_dup13 (gchar** self,
                   gssize length)
{
#line 81 "Spawn.vala"
	if (length >= 0) {
#line 192 "Spawn.vala.c"
		gchar** result;
		gssize i;
#line 81 "Spawn.vala"
		result = g_new0 (gchar*, length + 1);
#line 81 "Spawn.vala"
		for (i = 0; i < length; i++) {
#line 199 "Spawn.vala.c"
			gchar* _tmp0_;
#line 81 "Spawn.vala"
			_tmp0_ = g_strdup (self[i]);
#line 81 "Spawn.vala"
			result[i] = _tmp0_;
#line 205 "Spawn.vala.c"
		}
#line 81 "Spawn.vala"
		return result;
#line 209 "Spawn.vala.c"
	}
#line 81 "Spawn.vala"
	return NULL;
#line 213 "Spawn.vala.c"
}

Spawn*
spawn_construct (GType object_type,
                 const gchar* cwd,
                 gchar** args,
                 gint args_length1,
                 GError** error)
{
	Spawn * self = NULL;
	gchar* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar** _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gchar* _tmp11_;
	gchar** _tmp12_;
	gint _tmp12__length1;
	GError* _inner_error0_ = NULL;
#line 76 "Spawn.vala"
	self = (Spawn*) g_object_new (object_type, NULL);
#line 80 "Spawn.vala"
	_tmp0_ = g_strdup (cwd);
#line 80 "Spawn.vala"
	_g_free0 (self->cwd);
#line 80 "Spawn.vala"
	self->cwd = _tmp0_;
#line 81 "Spawn.vala"
	_tmp1_ = (args != NULL) ? _vala_array_dup13 (args, args_length1) : args;
#line 81 "Spawn.vala"
	_tmp1__length1 = args_length1;
#line 81 "Spawn.vala"
	self->args = (_vala_array_free (self->args, self->args_length1, (GDestroyNotify) g_free), NULL);
#line 81 "Spawn.vala"
	self->args = _tmp1_;
#line 81 "Spawn.vala"
	self->args_length1 = _tmp1__length1;
#line 82 "Spawn.vala"
	_tmp2_ = g_new0 (gchar*, 0 + 1);
#line 82 "Spawn.vala"
	self->env = (_vala_array_free (self->env, self->env_length1, (GDestroyNotify) g_free), NULL);
#line 82 "Spawn.vala"
	self->env = _tmp2_;
#line 82 "Spawn.vala"
	self->env_length1 = 0;
#line 84 "Spawn.vala"
	_tmp3_ = g_strdup ("");
#line 84 "Spawn.vala"
	_g_free0 (self->output);
#line 84 "Spawn.vala"
	self->output = _tmp3_;
#line 85 "Spawn.vala"
	_tmp4_ = g_strdup ("");
#line 85 "Spawn.vala"
	_g_free0 (self->stderr);
#line 85 "Spawn.vala"
	self->stderr = _tmp4_;
#line 87 "Spawn.vala"
	_tmp6_ = self->cwd;
#line 87 "Spawn.vala"
	_tmp7_ = strlen (_tmp6_);
#line 87 "Spawn.vala"
	_tmp8_ = _tmp7_;
#line 87 "Spawn.vala"
	if (_tmp8_ < 1) {
#line 284 "Spawn.vala.c"
		const gchar* _tmp9_;
#line 87 "Spawn.vala"
		_tmp9_ = g_get_home_dir ();
#line 87 "Spawn.vala"
		_tmp5_ = _tmp9_;
#line 290 "Spawn.vala.c"
	} else {
		const gchar* _tmp10_;
#line 87 "Spawn.vala"
		_tmp10_ = self->cwd;
#line 87 "Spawn.vala"
		_tmp5_ = _tmp10_;
#line 297 "Spawn.vala.c"
	}
#line 87 "Spawn.vala"
	_tmp11_ = g_strdup (_tmp5_);
#line 87 "Spawn.vala"
	_g_free0 (self->cwd);
#line 87 "Spawn.vala"
	self->cwd = _tmp11_;
#line 88 "Spawn.vala"
	_tmp12_ = self->args;
#line 88 "Spawn.vala"
	_tmp12__length1 = self->args_length1;
#line 88 "Spawn.vala"
	if (_tmp12__length1 < 0) {
#line 311 "Spawn.vala.c"
		GError* _tmp13_;
#line 89 "Spawn.vala"
		_tmp13_ = g_error_new_literal (SPAWN_ERROR, SPAWN_ERROR_NO_ARGS, "No arguments");
#line 89 "Spawn.vala"
		_inner_error0_ = _tmp13_;
#line 89 "Spawn.vala"
		g_propagate_error (error, _inner_error0_);
#line 89 "Spawn.vala"
		_g_object_unref0 (self);
#line 89 "Spawn.vala"
		return NULL;
#line 323 "Spawn.vala.c"
	}
#line 76 "Spawn.vala"
	return self;
#line 327 "Spawn.vala.c"
}

Spawn*
spawn_new (const gchar* cwd,
           gchar** args,
           gint args_length1,
           GError** error)
{
#line 76 "Spawn.vala"
	return spawn_construct (TYPE_SPAWN, cwd, args, args_length1, error);
#line 338 "Spawn.vala.c"
}

/**
     * 
     * @method run
     * Run the configured command.
     * result is applied to object properties (eg. '?' or 'stderr')
     * @returns {Object} self.
     */
static gchar*
_vala_g_strjoinv (const gchar* separator,
                  gchar** str_array,
                  gint str_array_length1)
{
	gboolean _tmp0_ = FALSE;
	gchar* result;
#line 1208 "glib-2.0.vapi"
	if (separator == NULL) {
#line 1209 "glib-2.0.vapi"
		separator = "";
#line 359 "Spawn.vala.c"
	}
#line 1211 "glib-2.0.vapi"
	if (str_array != NULL) {
#line 363 "Spawn.vala.c"
		gboolean _tmp1_ = FALSE;
#line 1211 "glib-2.0.vapi"
		if (str_array_length1 > 0) {
#line 1211 "glib-2.0.vapi"
			_tmp1_ = TRUE;
#line 369 "Spawn.vala.c"
		} else {
			gboolean _tmp2_ = FALSE;
#line 1211 "glib-2.0.vapi"
			if (str_array_length1 == -1) {
#line 374 "Spawn.vala.c"
				const gchar* _tmp3_;
#line 1211 "glib-2.0.vapi"
				_tmp3_ = str_array[0];
#line 1211 "glib-2.0.vapi"
				_tmp2_ = _tmp3_ != NULL;
#line 380 "Spawn.vala.c"
			} else {
#line 1211 "glib-2.0.vapi"
				_tmp2_ = FALSE;
#line 384 "Spawn.vala.c"
			}
#line 1211 "glib-2.0.vapi"
			_tmp1_ = _tmp2_;
#line 388 "Spawn.vala.c"
		}
#line 1211 "glib-2.0.vapi"
		_tmp0_ = _tmp1_;
#line 392 "Spawn.vala.c"
	} else {
#line 1211 "glib-2.0.vapi"
		_tmp0_ = FALSE;
#line 396 "Spawn.vala.c"
	}
#line 1211 "glib-2.0.vapi"
	if (_tmp0_) {
#line 400 "Spawn.vala.c"
		gint i = 0;
		gsize len = 0UL;
		gint _tmp16_;
		gint _tmp17_;
		const gchar* res = NULL;
		void* _tmp18_;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_;
		void* ptr = NULL;
		const gchar* _tmp22_;
		void* _tmp23_;
		const gchar* _tmp33_;
#line 1213 "glib-2.0.vapi"
		len = (gsize) 1;
#line 415 "Spawn.vala.c"
		{
			gboolean _tmp4_ = FALSE;
#line 1214 "glib-2.0.vapi"
			i = 0;
#line 1214 "glib-2.0.vapi"
			_tmp4_ = TRUE;
#line 1214 "glib-2.0.vapi"
			while (TRUE) {
#line 424 "Spawn.vala.c"
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				gint _tmp10_ = 0;
				const gchar* _tmp11_;
#line 1214 "glib-2.0.vapi"
				if (!_tmp4_) {
#line 431 "Spawn.vala.c"
					gint _tmp5_;
#line 1214 "glib-2.0.vapi"
					_tmp5_ = i;
#line 1214 "glib-2.0.vapi"
					i = _tmp5_ + 1;
#line 437 "Spawn.vala.c"
				}
#line 1214 "glib-2.0.vapi"
				_tmp4_ = FALSE;
#line 1214 "glib-2.0.vapi"
				if (str_array_length1 != -1) {
#line 1214 "glib-2.0.vapi"
					_tmp7_ = i < str_array_length1;
#line 445 "Spawn.vala.c"
				} else {
#line 1214 "glib-2.0.vapi"
					_tmp7_ = FALSE;
#line 449 "Spawn.vala.c"
				}
#line 1214 "glib-2.0.vapi"
				if (_tmp7_) {
#line 1214 "glib-2.0.vapi"
					_tmp6_ = TRUE;
#line 455 "Spawn.vala.c"
				} else {
					gboolean _tmp8_ = FALSE;
#line 1214 "glib-2.0.vapi"
					if (str_array_length1 == -1) {
#line 460 "Spawn.vala.c"
						const gchar* _tmp9_;
#line 1214 "glib-2.0.vapi"
						_tmp9_ = str_array[i];
#line 1214 "glib-2.0.vapi"
						_tmp8_ = _tmp9_ != NULL;
#line 466 "Spawn.vala.c"
					} else {
#line 1214 "glib-2.0.vapi"
						_tmp8_ = FALSE;
#line 470 "Spawn.vala.c"
					}
#line 1214 "glib-2.0.vapi"
					_tmp6_ = _tmp8_;
#line 474 "Spawn.vala.c"
				}
#line 1214 "glib-2.0.vapi"
				if (!_tmp6_) {
#line 1214 "glib-2.0.vapi"
					break;
#line 480 "Spawn.vala.c"
				}
#line 1215 "glib-2.0.vapi"
				_tmp11_ = str_array[i];
#line 1215 "glib-2.0.vapi"
				if (_tmp11_ != NULL) {
#line 486 "Spawn.vala.c"
					const gchar* _tmp12_;
					gint _tmp13_;
					gint _tmp14_;
#line 1215 "glib-2.0.vapi"
					_tmp12_ = str_array[i];
#line 1215 "glib-2.0.vapi"
					_tmp13_ = strlen ((const gchar*) _tmp12_);
#line 1215 "glib-2.0.vapi"
					_tmp14_ = _tmp13_;
#line 1215 "glib-2.0.vapi"
					_tmp10_ = _tmp14_;
#line 498 "Spawn.vala.c"
				} else {
#line 1215 "glib-2.0.vapi"
					_tmp10_ = 0;
#line 502 "Spawn.vala.c"
				}
#line 1215 "glib-2.0.vapi"
				len += (gsize) _tmp10_;
#line 506 "Spawn.vala.c"
			}
		}
#line 1217 "glib-2.0.vapi"
		if (i == 0) {
#line 511 "Spawn.vala.c"
			gchar* _tmp15_;
#line 1218 "glib-2.0.vapi"
			_tmp15_ = g_strdup ("");
#line 1218 "glib-2.0.vapi"
			result = _tmp15_;
#line 1218 "glib-2.0.vapi"
			return result;
#line 519 "Spawn.vala.c"
		}
#line 1220 "glib-2.0.vapi"
		str_array_length1 = i;
#line 1221 "glib-2.0.vapi"
		_tmp16_ = strlen ((const gchar*) separator);
#line 1221 "glib-2.0.vapi"
		_tmp17_ = _tmp16_;
#line 1221 "glib-2.0.vapi"
		len += (gsize) (_tmp17_ * (i - 1));
#line 1223 "glib-2.0.vapi"
		_tmp18_ = g_malloc (len);
#line 1223 "glib-2.0.vapi"
		res = _tmp18_;
#line 1224 "glib-2.0.vapi"
		_tmp20_ = str_array[0];
#line 1224 "glib-2.0.vapi"
		if (_tmp20_ != NULL) {
#line 537 "Spawn.vala.c"
			const gchar* _tmp21_;
#line 1224 "glib-2.0.vapi"
			_tmp21_ = str_array[0];
#line 1224 "glib-2.0.vapi"
			_tmp19_ = (const gchar*) _tmp21_;
#line 543 "Spawn.vala.c"
		} else {
#line 1224 "glib-2.0.vapi"
			_tmp19_ = "";
#line 547 "Spawn.vala.c"
		}
#line 1224 "glib-2.0.vapi"
		_tmp22_ = res;
#line 1224 "glib-2.0.vapi"
		_tmp23_ = g_stpcpy ((void*) _tmp22_, _tmp19_);
#line 1224 "glib-2.0.vapi"
		ptr = _tmp23_;
#line 555 "Spawn.vala.c"
		{
			gboolean _tmp24_ = FALSE;
#line 1225 "glib-2.0.vapi"
			i = 1;
#line 1225 "glib-2.0.vapi"
			_tmp24_ = TRUE;
#line 1225 "glib-2.0.vapi"
			while (TRUE) {
#line 564 "Spawn.vala.c"
				void* _tmp26_;
				void* _tmp27_;
				const gchar* _tmp28_ = NULL;
				const gchar* _tmp29_;
				void* _tmp31_;
				void* _tmp32_;
#line 1225 "glib-2.0.vapi"
				if (!_tmp24_) {
#line 573 "Spawn.vala.c"
					gint _tmp25_;
#line 1225 "glib-2.0.vapi"
					_tmp25_ = i;
#line 1225 "glib-2.0.vapi"
					i = _tmp25_ + 1;
#line 579 "Spawn.vala.c"
				}
#line 1225 "glib-2.0.vapi"
				_tmp24_ = FALSE;
#line 1225 "glib-2.0.vapi"
				if (!(i < str_array_length1)) {
#line 1225 "glib-2.0.vapi"
					break;
#line 587 "Spawn.vala.c"
				}
#line 1226 "glib-2.0.vapi"
				_tmp26_ = ptr;
#line 1226 "glib-2.0.vapi"
				_tmp27_ = g_stpcpy (_tmp26_, (const gchar*) separator);
#line 1226 "glib-2.0.vapi"
				ptr = _tmp27_;
#line 1227 "glib-2.0.vapi"
				_tmp29_ = str_array[i];
#line 1227 "glib-2.0.vapi"
				if (_tmp29_ != NULL) {
#line 599 "Spawn.vala.c"
					const gchar* _tmp30_;
#line 1227 "glib-2.0.vapi"
					_tmp30_ = str_array[i];
#line 1227 "glib-2.0.vapi"
					_tmp28_ = (const gchar*) _tmp30_;
#line 605 "Spawn.vala.c"
				} else {
#line 1227 "glib-2.0.vapi"
					_tmp28_ = "";
#line 609 "Spawn.vala.c"
				}
#line 1227 "glib-2.0.vapi"
				_tmp31_ = ptr;
#line 1227 "glib-2.0.vapi"
				_tmp32_ = g_stpcpy (_tmp31_, _tmp28_);
#line 1227 "glib-2.0.vapi"
				ptr = _tmp32_;
#line 617 "Spawn.vala.c"
			}
		}
#line 1230 "glib-2.0.vapi"
		_tmp33_ = res;
#line 1230 "glib-2.0.vapi"
		res = NULL;
#line 1230 "glib-2.0.vapi"
		result = (gchar*) _tmp33_;
#line 1230 "glib-2.0.vapi"
		return result;
#line 628 "Spawn.vala.c"
	} else {
		gchar* _tmp34_;
#line 1232 "glib-2.0.vapi"
		_tmp34_ = g_strdup ("");
#line 1232 "glib-2.0.vapi"
		result = _tmp34_;
#line 1232 "glib-2.0.vapi"
		return result;
#line 637 "Spawn.vala.c"
	}
}

static void
___lambda33_ (Spawn* self,
              GPid pid,
              gint status)
{
#line 167 "Spawn.vala"
	g_spawn_close_pid (pid);
#line 648 "Spawn.vala.c"
}

static void
____lambda33__gchild_watch_func (GPid pid,
                                 gint wait_status,
                                 gpointer self)
{
#line 165 "Spawn.vala"
	___lambda33_ ((Spawn*) self, pid, wait_status);
#line 658 "Spawn.vala.c"
}

static void
__lambda34_ (Spawn* self,
             GPid w_pid,
             gint _result_)
{
	GIOChannel* _tmp0_;
	GIOChannel* _tmp1_;
	GMainLoop* _tmp2_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
#line 212 "Spawn.vala"
	self->result = _result_;
#line 213 "Spawn.vala"
	g_debug ("Spawn.vala:213: child_watch_add : result:%d ", _result_);
#line 216 "Spawn.vala"
	_tmp0_ = self->priv->out_ch;
#line 216 "Spawn.vala"
	spawn_read (self, _tmp0_);
#line 217 "Spawn.vala"
	_tmp1_ = self->priv->err_ch;
#line 217 "Spawn.vala"
	spawn_read (self, _tmp1_);
#line 220 "Spawn.vala"
	g_spawn_close_pid ((GPid) self->priv->pid);
#line 221 "Spawn.vala"
	self->priv->pid = -1;
#line 222 "Spawn.vala"
	_tmp2_ = self->priv->ctx;
#line 222 "Spawn.vala"
	if (_tmp2_ != NULL) {
#line 691 "Spawn.vala.c"
		GMainLoop* _tmp3_;
#line 223 "Spawn.vala"
		_tmp3_ = self->priv->ctx;
#line 223 "Spawn.vala"
		g_main_loop_quit (_tmp3_);
#line 224 "Spawn.vala"
		_g_main_loop_unref0 (self->priv->ctx);
#line 224 "Spawn.vala"
		self->priv->ctx = NULL;
#line 701 "Spawn.vala.c"
	}
#line 226 "Spawn.vala"
	spawn_tidyup (self);
#line 229 "Spawn.vala"
	_tmp4_ = self->output;
#line 229 "Spawn.vala"
	_tmp5_ = self->stderr;
#line 229 "Spawn.vala"
	g_signal_emit (self, spawn_signals[SPAWN_COMPLETE_SIGNAL], 0, self->result, _tmp4_, _tmp5_);
#line 711 "Spawn.vala.c"
}

static void
___lambda34__gchild_watch_func (GPid pid,
                                gint wait_status,
                                gpointer self)
{
#line 210 "Spawn.vala"
	__lambda34_ ((Spawn*) self, pid, wait_status);
#line 721 "Spawn.vala.c"
}

static gboolean
__lambda35_ (Spawn* self,
             GIOChannel* channel,
             GIOCondition condition)
{
	GIOChannel* _tmp0_;
	gboolean result;
#line 243 "Spawn.vala"
	_tmp0_ = self->priv->out_ch;
#line 243 "Spawn.vala"
	result = spawn_read (self, _tmp0_);
#line 243 "Spawn.vala"
	return result;
#line 737 "Spawn.vala.c"
}

static gboolean
___lambda35__gio_func (GIOChannel* source,
                       GIOCondition condition,
                       gpointer self)
{
	gboolean result;
	result = __lambda35_ ((Spawn*) self, source, condition);
#line 240 "Spawn.vala"
	return result;
#line 749 "Spawn.vala.c"
}

static gboolean
__lambda36_ (Spawn* self,
             GIOChannel* channel,
             GIOCondition condition)
{
	GIOChannel* _tmp0_;
	gboolean result;
#line 249 "Spawn.vala"
	_tmp0_ = self->priv->err_ch;
#line 249 "Spawn.vala"
	result = spawn_read (self, _tmp0_);
#line 249 "Spawn.vala"
	return result;
#line 765 "Spawn.vala.c"
}

static gboolean
___lambda36__gio_func (GIOChannel* source,
                       GIOCondition condition,
                       gpointer self)
{
	gboolean result;
	result = __lambda36_ ((Spawn*) self, source, condition);
#line 246 "Spawn.vala"
	return result;
#line 777 "Spawn.vala.c"
}

void
spawn_run (Spawn* self,
           GError** error)
{
	gint standard_input = 0;
	gint standard_output = 0;
	gint standard_error = 0;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar** _tmp10_ = NULL;
	gint _tmp10__length1 = 0;
	gint __tmp10__size_ = 0;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp13_;
	gchar** _tmp14_;
	gint _tmp14__length1;
	GPid _tmp15_ = 0;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	gint _tmp18_ = 0;
	GIOChannel* _tmp19_;
	GIOChannel* _tmp20_;
	GIOChannel* _tmp21_;
	GIOChannel* _tmp22_;
	GIOChannel* _tmp23_;
	GIOChannel* _tmp24_;
	GIOChannel* _tmp25_;
	GIOChannel* _tmp26_;
	gboolean _tmp31_ = FALSE;
	gboolean _tmp34_ = FALSE;
	GError* _inner_error0_ = NULL;
#line 147 "Spawn.vala"
	self->priv->err_src = -1;
#line 148 "Spawn.vala"
	self->priv->out_src = -1;
#line 155 "Spawn.vala"
	_tmp0_ = self->cwd;
#line 155 "Spawn.vala"
	_tmp1_ = self->args;
#line 155 "Spawn.vala"
	_tmp1__length1 = self->args_length1;
#line 155 "Spawn.vala"
	_tmp2_ = _vala_g_strjoinv (" ", _tmp1_, (gint) _tmp1__length1);
#line 155 "Spawn.vala"
	_tmp3_ = _tmp2_;
#line 155 "Spawn.vala"
	g_debug ("Spawn.vala:155: cd %s; %s", _tmp0_, _tmp3_);
#line 155 "Spawn.vala"
	_g_free0 (_tmp3_);
#line 157 "Spawn.vala"
	if (self->detach) {
#line 835 "Spawn.vala.c"
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		gint __tmp4__size_ = 0;
		gchar** _tmp5_;
		gint _tmp5__length1;
		const gchar* _tmp7_;
		gchar** _tmp8_;
		gint _tmp8__length1;
		GPid _tmp9_ = 0;
#line 161 "Spawn.vala"
		_tmp5_ = self->env;
#line 161 "Spawn.vala"
		_tmp5__length1 = self->env_length1;
#line 161 "Spawn.vala"
		if (_tmp5__length1 > 0) {
#line 851 "Spawn.vala.c"
			gchar** _tmp6_;
			gint _tmp6__length1;
#line 161 "Spawn.vala"
			_tmp6_ = self->env;
#line 161 "Spawn.vala"
			_tmp6__length1 = self->env_length1;
#line 161 "Spawn.vala"
			_tmp4_ = _tmp6_;
#line 161 "Spawn.vala"
			_tmp4__length1 = _tmp6__length1;
#line 161 "Spawn.vala"
			__tmp4__size_ = _tmp4__length1;
#line 864 "Spawn.vala.c"
		} else {
#line 161 "Spawn.vala"
			_tmp4_ = NULL;
#line 161 "Spawn.vala"
			_tmp4__length1 = 0;
#line 161 "Spawn.vala"
			__tmp4__size_ = _tmp4__length1;
#line 872 "Spawn.vala.c"
		}
#line 158 "Spawn.vala"
		_tmp7_ = self->cwd;
#line 158 "Spawn.vala"
		_tmp8_ = self->args;
#line 158 "Spawn.vala"
		_tmp8__length1 = self->args_length1;
#line 158 "Spawn.vala"
		g_spawn_async_with_pipes (_tmp7_, _tmp8_, _tmp4_, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp9_, NULL, NULL, NULL, &_inner_error0_);
#line 158 "Spawn.vala"
		self->priv->pid = (gint) _tmp9_;
#line 158 "Spawn.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 158 "Spawn.vala"
			if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 158 "Spawn.vala"
				g_propagate_error (error, _inner_error0_);
#line 158 "Spawn.vala"
				return;
#line 892 "Spawn.vala.c"
			} else {
#line 158 "Spawn.vala"
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 158 "Spawn.vala"
				g_clear_error (&_inner_error0_);
#line 158 "Spawn.vala"
				return;
#line 900 "Spawn.vala.c"
			}
		}
#line 165 "Spawn.vala"
		g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, (GPid) self->priv->pid, ____lambda33__gchild_watch_func, g_object_ref (self), g_object_unref);
#line 171 "Spawn.vala"
		return;
#line 907 "Spawn.vala.c"
	}
#line 177 "Spawn.vala"
	_tmp11_ = self->env;
#line 177 "Spawn.vala"
	_tmp11__length1 = self->env_length1;
#line 177 "Spawn.vala"
	if (_tmp11__length1 > 0) {
#line 915 "Spawn.vala.c"
		gchar** _tmp12_;
		gint _tmp12__length1;
#line 177 "Spawn.vala"
		_tmp12_ = self->env;
#line 177 "Spawn.vala"
		_tmp12__length1 = self->env_length1;
#line 177 "Spawn.vala"
		_tmp10_ = _tmp12_;
#line 177 "Spawn.vala"
		_tmp10__length1 = _tmp12__length1;
#line 177 "Spawn.vala"
		__tmp10__size_ = _tmp10__length1;
#line 928 "Spawn.vala.c"
	} else {
#line 177 "Spawn.vala"
		_tmp10_ = NULL;
#line 177 "Spawn.vala"
		_tmp10__length1 = 0;
#line 177 "Spawn.vala"
		__tmp10__size_ = _tmp10__length1;
#line 936 "Spawn.vala.c"
	}
#line 174 "Spawn.vala"
	_tmp13_ = self->cwd;
#line 174 "Spawn.vala"
	_tmp14_ = self->args;
#line 174 "Spawn.vala"
	_tmp14__length1 = self->args_length1;
#line 174 "Spawn.vala"
	g_spawn_async_with_pipes (_tmp13_, _tmp14_, _tmp10_, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp15_, &_tmp16_, &_tmp17_, &_tmp18_, &_inner_error0_);
#line 174 "Spawn.vala"
	self->priv->pid = (gint) _tmp15_;
#line 174 "Spawn.vala"
	standard_input = _tmp16_;
#line 174 "Spawn.vala"
	standard_output = _tmp17_;
#line 174 "Spawn.vala"
	standard_error = _tmp18_;
#line 174 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 174 "Spawn.vala"
		if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 174 "Spawn.vala"
			g_propagate_error (error, _inner_error0_);
#line 174 "Spawn.vala"
			return;
#line 962 "Spawn.vala.c"
		} else {
#line 174 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 174 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 174 "Spawn.vala"
			return;
#line 970 "Spawn.vala.c"
		}
	}
#line 190 "Spawn.vala"
	g_debug ("Spawn.vala:190: PID: %d", self->priv->pid);
#line 193 "Spawn.vala"
	_tmp19_ = g_io_channel_unix_new (standard_input);
#line 193 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->in_ch);
#line 193 "Spawn.vala"
	self->priv->in_ch = _tmp19_;
#line 194 "Spawn.vala"
	_tmp20_ = g_io_channel_unix_new (standard_output);
#line 194 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->out_ch);
#line 194 "Spawn.vala"
	self->priv->out_ch = _tmp20_;
#line 195 "Spawn.vala"
	_tmp21_ = g_io_channel_unix_new (standard_error);
#line 195 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->err_ch);
#line 195 "Spawn.vala"
	self->priv->err_ch = _tmp21_;
#line 203 "Spawn.vala"
	_tmp22_ = self->priv->in_ch;
#line 203 "Spawn.vala"
	g_io_channel_set_flags (_tmp22_, G_IO_FLAG_NONBLOCK, &_inner_error0_);
#line 203 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 203 "Spawn.vala"
		if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 203 "Spawn.vala"
			g_propagate_error (error, _inner_error0_);
#line 203 "Spawn.vala"
			return;
#line 1005 "Spawn.vala.c"
		} else {
#line 203 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 203 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 203 "Spawn.vala"
			return;
#line 1013 "Spawn.vala.c"
		}
	}
#line 204 "Spawn.vala"
	_tmp23_ = self->priv->out_ch;
#line 204 "Spawn.vala"
	g_io_channel_set_flags (_tmp23_, G_IO_FLAG_NONBLOCK, &_inner_error0_);
#line 204 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 204 "Spawn.vala"
		if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 204 "Spawn.vala"
			g_propagate_error (error, _inner_error0_);
#line 204 "Spawn.vala"
			return;
#line 1028 "Spawn.vala.c"
		} else {
#line 204 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 204 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 204 "Spawn.vala"
			return;
#line 1036 "Spawn.vala.c"
		}
	}
#line 205 "Spawn.vala"
	_tmp24_ = self->priv->err_ch;
#line 205 "Spawn.vala"
	g_io_channel_set_flags (_tmp24_, G_IO_FLAG_NONBLOCK, &_inner_error0_);
#line 205 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 205 "Spawn.vala"
		if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 205 "Spawn.vala"
			g_propagate_error (error, _inner_error0_);
#line 205 "Spawn.vala"
			return;
#line 1051 "Spawn.vala.c"
		} else {
#line 205 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 205 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 205 "Spawn.vala"
			return;
#line 1059 "Spawn.vala.c"
		}
	}
#line 210 "Spawn.vala"
	g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, (GPid) self->priv->pid, ___lambda34__gchild_watch_func, g_object_ref (self), g_object_unref);
#line 240 "Spawn.vala"
	_tmp25_ = self->priv->out_ch;
#line 240 "Spawn.vala"
	self->priv->out_src = (gint) g_io_add_watch (_tmp25_, (((G_IO_OUT | G_IO_IN) | G_IO_PRI) | G_IO_HUP) | G_IO_ERR, ___lambda35__gio_func, self);
#line 246 "Spawn.vala"
	_tmp26_ = self->priv->err_ch;
#line 246 "Spawn.vala"
	self->priv->err_src = (gint) g_io_add_watch (_tmp26_, (((G_IO_OUT | G_IO_IN) | G_IO_PRI) | G_IO_HUP) | G_IO_ERR, ___lambda36__gio_func, self);
#line 255 "Spawn.vala"
	if (self->priv->pid > -1) {
#line 1074 "Spawn.vala.c"
		gchar* input = NULL;
		gchar* _tmp27_ = NULL;
		const gchar* _tmp28_;
#line 257 "Spawn.vala"
		g_signal_emit (self, spawn_signals[SPAWN_INPUT_SIGNAL], 0, &_tmp27_);
#line 257 "Spawn.vala"
		input = _tmp27_;
#line 258 "Spawn.vala"
		_tmp28_ = input;
#line 258 "Spawn.vala"
		if (_tmp28_ != NULL) {
#line 1086 "Spawn.vala.c"
			{
				const gchar* _tmp29_;
				GIOChannel* _tmp30_;
#line 261 "Spawn.vala"
				_tmp29_ = input;
#line 261 "Spawn.vala"
				spawn_write (self, _tmp29_, &_inner_error0_);
#line 261 "Spawn.vala"
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1096 "Spawn.vala.c"
					goto __catch0_g_error;
				}
#line 264 "Spawn.vala"
				_tmp30_ = self->priv->in_ch;
#line 264 "Spawn.vala"
				g_io_channel_shutdown (_tmp30_, TRUE, &_inner_error0_);
#line 264 "Spawn.vala"
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1105 "Spawn.vala.c"
					goto __catch0_g_error;
				}
#line 265 "Spawn.vala"
				_g_io_channel_unref0 (self->priv->in_ch);
#line 265 "Spawn.vala"
				self->priv->in_ch = NULL;
#line 1112 "Spawn.vala.c"
			}
			goto __finally0;
			__catch0_g_error:
			{
#line 260 "Spawn.vala"
				g_clear_error (&_inner_error0_);
#line 269 "Spawn.vala"
				spawn_tidyup (self);
#line 270 "Spawn.vala"
				_g_free0 (input);
#line 270 "Spawn.vala"
				return;
#line 1125 "Spawn.vala.c"
			}
			__finally0:
#line 260 "Spawn.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 260 "Spawn.vala"
				if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 260 "Spawn.vala"
					g_propagate_error (error, _inner_error0_);
#line 260 "Spawn.vala"
					_g_free0 (input);
#line 260 "Spawn.vala"
					return;
#line 1138 "Spawn.vala.c"
				} else {
#line 260 "Spawn.vala"
					_g_free0 (input);
#line 260 "Spawn.vala"
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 260 "Spawn.vala"
					g_clear_error (&_inner_error0_);
#line 260 "Spawn.vala"
					return;
#line 1148 "Spawn.vala.c"
				}
			}
		}
#line 255 "Spawn.vala"
		_g_free0 (input);
#line 1154 "Spawn.vala.c"
	}
#line 279 "Spawn.vala"
	if (self->is_async) {
#line 279 "Spawn.vala"
		_tmp31_ = self->priv->pid > -1;
#line 1160 "Spawn.vala.c"
	} else {
#line 279 "Spawn.vala"
		_tmp31_ = FALSE;
#line 1164 "Spawn.vala.c"
	}
#line 279 "Spawn.vala"
	if (_tmp31_) {
#line 280 "Spawn.vala"
		return;
#line 1170 "Spawn.vala.c"
	}
#line 285 "Spawn.vala"
	if (self->priv->pid > -1) {
#line 1174 "Spawn.vala.c"
		GMainLoop* _tmp32_;
		GMainLoop* _tmp33_;
#line 286 "Spawn.vala"
		g_debug ("Spawn.vala:286: starting main loop");
#line 290 "Spawn.vala"
		_tmp32_ = g_main_loop_new (NULL, FALSE);
#line 290 "Spawn.vala"
		_g_main_loop_unref0 (self->priv->ctx);
#line 290 "Spawn.vala"
		self->priv->ctx = _tmp32_;
#line 291 "Spawn.vala"
		_tmp33_ = self->priv->ctx;
#line 291 "Spawn.vala"
		g_main_loop_run (_tmp33_);
#line 293 "Spawn.vala"
		g_debug ("Spawn.vala:293: main_loop done!");
#line 1191 "Spawn.vala.c"
	} else {
#line 295 "Spawn.vala"
		spawn_tidyup (self);
#line 1195 "Spawn.vala.c"
	}
#line 298 "Spawn.vala"
	if (self->throw_exceptions) {
#line 298 "Spawn.vala"
		_tmp34_ = self->result != 0;
#line 1201 "Spawn.vala.c"
	} else {
#line 298 "Spawn.vala"
		_tmp34_ = FALSE;
#line 1205 "Spawn.vala.c"
	}
#line 298 "Spawn.vala"
	if (_tmp34_) {
#line 1209 "Spawn.vala.c"
		const gchar* _tmp35_;
		GError* _tmp36_;
#line 300 "Spawn.vala"
		_tmp35_ = self->stderr;
#line 300 "Spawn.vala"
		_tmp36_ = g_error_new_literal (SPAWN_ERROR, SPAWN_ERROR_EXECUTE_ERROR, _tmp35_);
#line 300 "Spawn.vala"
		_inner_error0_ = _tmp36_;
#line 300 "Spawn.vala"
		if (((_inner_error0_->domain == SPAWN_ERROR) || (_inner_error0_->domain == G_SPAWN_ERROR)) || (_inner_error0_->domain == G_IO_CHANNEL_ERROR)) {
#line 300 "Spawn.vala"
			g_propagate_error (error, _inner_error0_);
#line 300 "Spawn.vala"
			return;
#line 1224 "Spawn.vala.c"
		} else {
#line 300 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 300 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 300 "Spawn.vala"
			return;
#line 1232 "Spawn.vala.c"
		}
	}
#line 307 "Spawn.vala"
	return;
#line 1237 "Spawn.vala.c"
}

static void
spawn_tidyup (Spawn* self)
{
	GError* _inner_error0_ = NULL;
#line 315 "Spawn.vala"
	if (self->priv->pid > -1) {
#line 316 "Spawn.vala"
		g_spawn_close_pid ((GPid) self->priv->pid);
#line 317 "Spawn.vala"
		self->priv->pid = -1;
#line 1250 "Spawn.vala.c"
	}
	{
		GIOChannel* _tmp0_;
		GIOChannel* _tmp2_;
		GIOChannel* _tmp4_;
#line 320 "Spawn.vala"
		_tmp0_ = self->priv->in_ch;
#line 320 "Spawn.vala"
		if (_tmp0_ != NULL) {
#line 1260 "Spawn.vala.c"
			GIOChannel* _tmp1_;
#line 320 "Spawn.vala"
			_tmp1_ = self->priv->in_ch;
#line 320 "Spawn.vala"
			g_io_channel_shutdown (_tmp1_, TRUE, &_inner_error0_);
#line 320 "Spawn.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1268 "Spawn.vala.c"
				goto __catch0_g_error;
			}
		}
#line 321 "Spawn.vala"
		_tmp2_ = self->priv->out_ch;
#line 321 "Spawn.vala"
		if (_tmp2_ != NULL) {
#line 1276 "Spawn.vala.c"
			GIOChannel* _tmp3_;
#line 321 "Spawn.vala"
			_tmp3_ = self->priv->out_ch;
#line 321 "Spawn.vala"
			g_io_channel_shutdown (_tmp3_, TRUE, &_inner_error0_);
#line 321 "Spawn.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1284 "Spawn.vala.c"
				goto __catch0_g_error;
			}
		}
#line 322 "Spawn.vala"
		_tmp4_ = self->priv->err_ch;
#line 322 "Spawn.vala"
		if (_tmp4_ != NULL) {
#line 1292 "Spawn.vala.c"
			GIOChannel* _tmp5_;
#line 322 "Spawn.vala"
			_tmp5_ = self->priv->err_ch;
#line 322 "Spawn.vala"
			g_io_channel_shutdown (_tmp5_, TRUE, &_inner_error0_);
#line 322 "Spawn.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1300 "Spawn.vala.c"
				goto __catch0_g_error;
			}
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
#line 319 "Spawn.vala"
		g_clear_error (&_inner_error0_);
#line 1310 "Spawn.vala.c"
	}
	__finally0:
#line 319 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 319 "Spawn.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 319 "Spawn.vala"
		g_clear_error (&_inner_error0_);
#line 319 "Spawn.vala"
		return;
#line 1321 "Spawn.vala.c"
	}
#line 327 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->in_ch);
#line 327 "Spawn.vala"
	self->priv->in_ch = NULL;
#line 328 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->err_ch);
#line 328 "Spawn.vala"
	self->priv->err_ch = NULL;
#line 329 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->out_ch);
#line 329 "Spawn.vala"
	self->priv->out_ch = NULL;
#line 333 "Spawn.vala"
	self->priv->err_src = -1;
#line 334 "Spawn.vala"
	self->priv->out_src = -1;
#line 1339 "Spawn.vala.c"
}

/**
     * write to stdin of process
     * @arg str {String} string to write to stdin of process
     * @returns GLib.IOStatus (0 == error, 1= NORMAL)
     */
static gchar*
string_to_utf8 (const gchar* self,
                gint* result_length1)
{
	gint string_length = 0;
	gint _tmp0_;
	gint _tmp1_;
	gchar* _result_ = NULL;
	gchar* _tmp2_;
	gint _result__length1;
	gint __result__size_;
	gint _tmp3_;
	gchar* _tmp4_;
	gint _tmp4__length1;
	gchar* result;
#line 1571 "glib-2.0.vapi"
	_tmp0_ = strlen (self);
#line 1571 "glib-2.0.vapi"
	_tmp1_ = _tmp0_;
#line 1571 "glib-2.0.vapi"
	string_length = _tmp1_;
#line 1572 "glib-2.0.vapi"
	_tmp2_ = g_new0 (gchar, string_length + 1);
#line 1572 "glib-2.0.vapi"
	_result_ = _tmp2_;
#line 1572 "glib-2.0.vapi"
	_result__length1 = string_length + 1;
#line 1572 "glib-2.0.vapi"
	__result__size_ = _result__length1;
#line 1573 "glib-2.0.vapi"
	_tmp3_ = _result__length1;
#line 1573 "glib-2.0.vapi"
	_result__length1 = _tmp3_ - 1;
#line 1574 "glib-2.0.vapi"
	memcpy (_result_, self, (gsize) string_length);
#line 1575 "glib-2.0.vapi"
	_tmp4_ = _result_;
#line 1575 "glib-2.0.vapi"
	_tmp4__length1 = _result__length1;
#line 1575 "glib-2.0.vapi"
	if (result_length1) {
#line 1575 "glib-2.0.vapi"
		*result_length1 = _tmp4__length1;
#line 1390 "Spawn.vala.c"
	}
#line 1575 "glib-2.0.vapi"
	result = _tmp4_;
#line 1575 "glib-2.0.vapi"
	return result;
#line 1396 "Spawn.vala.c"
}

static gint
spawn_write (Spawn* self,
             const gchar* str,
             GError** error)
{
	GIOChannel* _tmp0_;
	gsize written = 0UL;
	GIOStatus res = 0;
	GIOChannel* _tmp1_;
	gint _tmp2_ = 0;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gint _tmp4__length1;
	gsize _tmp5_ = 0UL;
	GIOStatus _tmp6_;
	GIOStatus _tmp7_;
	gint _tmp11_;
	gint _tmp12_;
	GError* _inner_error0_ = NULL;
	gint result;
#line 346 "Spawn.vala"
	_tmp0_ = self->priv->in_ch;
#line 346 "Spawn.vala"
	if (_tmp0_ == NULL) {
#line 347 "Spawn.vala"
		result = 0;
#line 347 "Spawn.vala"
		return result;
#line 1427 "Spawn.vala.c"
	}
#line 353 "Spawn.vala"
	_tmp1_ = self->priv->in_ch;
#line 353 "Spawn.vala"
	_tmp3_ = string_to_utf8 (str, &_tmp2_);
#line 353 "Spawn.vala"
	_tmp4_ = _tmp3_;
#line 353 "Spawn.vala"
	_tmp4__length1 = _tmp2_;
#line 353 "Spawn.vala"
	_tmp6_ = g_io_channel_write_chars (_tmp1_, _tmp4_, (gint) _tmp2_, &_tmp5_, &_inner_error0_);
#line 353 "Spawn.vala"
	written = _tmp5_;
#line 353 "Spawn.vala"
	_tmp7_ = _tmp6_;
#line 353 "Spawn.vala"
	_tmp4_ = (g_free (_tmp4_), NULL);
#line 353 "Spawn.vala"
	res = _tmp7_;
#line 353 "Spawn.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1449 "Spawn.vala.c"
		gint _tmp8_ = -1;
#line 353 "Spawn.vala"
		g_propagate_error (error, _inner_error0_);
#line 353 "Spawn.vala"
		return _tmp8_;
#line 1455 "Spawn.vala.c"
	}
#line 357 "Spawn.vala"
	if (res != G_IO_STATUS_NORMAL) {
#line 1459 "Spawn.vala.c"
		GError* _tmp9_;
		gint _tmp10_ = -1;
#line 358 "Spawn.vala"
		_tmp9_ = g_error_new_literal (SPAWN_ERROR, SPAWN_ERROR_WRITE_ERROR, "Write failed");
#line 358 "Spawn.vala"
		_inner_error0_ = _tmp9_;
#line 358 "Spawn.vala"
		g_propagate_error (error, _inner_error0_);
#line 358 "Spawn.vala"
		return _tmp10_;
#line 1470 "Spawn.vala.c"
	}
#line 361 "Spawn.vala"
	_tmp11_ = strlen (str);
#line 361 "Spawn.vala"
	_tmp12_ = _tmp11_;
#line 361 "Spawn.vala"
	result = _tmp12_;
#line 361 "Spawn.vala"
	return result;
#line 1480 "Spawn.vala.c"
}

/**
     * read from pipe and call appropriate listerner and add to output or stderr string.
     * @arg giochannel to read from.
     * @returns none
     */
static gboolean
spawn_read (Spawn* self,
            GIOChannel* ch)
{
	GError* _inner_error0_ = NULL;
	gboolean result;
#line 379 "Spawn.vala"
	while (TRUE) {
#line 1496 "Spawn.vala.c"
		gchar* buffer = NULL;
		gsize term_pos = 0UL;
		gsize len = 0UL;
		GIOStatus status = 0;
		{
			GIOStatus _tmp0_ = 0;
			gchar* _tmp1_ = NULL;
			gsize _tmp2_ = 0UL;
			gsize _tmp3_ = 0UL;
			GIOStatus _tmp4_;
#line 385 "Spawn.vala"
			_tmp4_ = g_io_channel_read_line (ch, &_tmp1_, &_tmp2_, &_tmp3_, &_inner_error0_);
#line 385 "Spawn.vala"
			_g_free0 (buffer);
#line 385 "Spawn.vala"
			buffer = _tmp1_;
#line 385 "Spawn.vala"
			len = _tmp2_;
#line 385 "Spawn.vala"
			term_pos = _tmp3_;
#line 385 "Spawn.vala"
			_tmp0_ = _tmp4_;
#line 385 "Spawn.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1521 "Spawn.vala.c"
				goto __catch0_g_error;
			}
#line 385 "Spawn.vala"
			status = _tmp0_;
#line 1526 "Spawn.vala.c"
		}
		goto __finally0;
		__catch0_g_error:
		{
#line 384 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 388 "Spawn.vala"
			_g_free0 (buffer);
#line 388 "Spawn.vala"
			break;
#line 1537 "Spawn.vala.c"
		}
		__finally0:
#line 384 "Spawn.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1542 "Spawn.vala.c"
			gboolean _tmp5_ = FALSE;
#line 384 "Spawn.vala"
			_g_free0 (buffer);
#line 384 "Spawn.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 384 "Spawn.vala"
			g_clear_error (&_inner_error0_);
#line 384 "Spawn.vala"
			return _tmp5_;
#line 1552 "Spawn.vala.c"
		}
#line 394 "Spawn.vala"
		switch (status) {
#line 394 "Spawn.vala"
			case G_IO_STATUS_NORMAL:
#line 1558 "Spawn.vala.c"
			{
				GIOChannel* _tmp6_;
#line 402 "Spawn.vala"
				_tmp6_ = self->priv->out_ch;
#line 402 "Spawn.vala"
				if (ch == _tmp6_) {
#line 1565 "Spawn.vala.c"
					const gchar* _tmp7_;
					const gchar* _tmp8_;
					gchar* _tmp9_;
					const gchar* _tmp10_;
#line 403 "Spawn.vala"
					_tmp7_ = self->output;
#line 403 "Spawn.vala"
					_tmp8_ = buffer;
#line 403 "Spawn.vala"
					_tmp9_ = g_strconcat (_tmp7_, _tmp8_, NULL);
#line 403 "Spawn.vala"
					_g_free0 (self->output);
#line 403 "Spawn.vala"
					self->output = _tmp9_;
#line 404 "Spawn.vala"
					_tmp10_ = buffer;
#line 404 "Spawn.vala"
					g_signal_emit (self, spawn_signals[SPAWN_OUTPUT_LINE_SIGNAL], 0, _tmp10_);
#line 1584 "Spawn.vala.c"
				} else {
					const gchar* _tmp11_;
					const gchar* _tmp12_;
					gchar* _tmp13_;
					const gchar* _tmp14_;
#line 407 "Spawn.vala"
					_tmp11_ = self->stderr;
#line 407 "Spawn.vala"
					_tmp12_ = buffer;
#line 407 "Spawn.vala"
					_tmp13_ = g_strconcat (_tmp11_, _tmp12_, NULL);
#line 407 "Spawn.vala"
					_g_free0 (self->stderr);
#line 407 "Spawn.vala"
					self->stderr = _tmp13_;
#line 408 "Spawn.vala"
					_tmp14_ = buffer;
#line 408 "Spawn.vala"
					g_signal_emit (self, spawn_signals[SPAWN_OUTPUT_LINE_SIGNAL], 0, _tmp14_);
#line 1604 "Spawn.vala.c"
				}
#line 414 "Spawn.vala"
				if (self->is_async) {
#line 1608 "Spawn.vala.c"
				}
#line 423 "Spawn.vala"
				_g_free0 (buffer);
#line 423 "Spawn.vala"
				continue;
#line 1614 "Spawn.vala.c"
			}
#line 394 "Spawn.vala"
			case G_IO_STATUS_AGAIN:
#line 1618 "Spawn.vala.c"
			{
#line 426 "Spawn.vala"
				result = TRUE;
#line 426 "Spawn.vala"
				_g_free0 (buffer);
#line 426 "Spawn.vala"
				return result;
#line 1626 "Spawn.vala.c"
			}
#line 394 "Spawn.vala"
			case G_IO_STATUS_ERROR:
#line 394 "Spawn.vala"
			case G_IO_STATUS_EOF:
#line 1632 "Spawn.vala.c"
			{
#line 430 "Spawn.vala"
				result = FALSE;
#line 430 "Spawn.vala"
				_g_free0 (buffer);
#line 430 "Spawn.vala"
				return result;
#line 1640 "Spawn.vala.c"
			}
			default:
#line 394 "Spawn.vala"
			break;
#line 1645 "Spawn.vala.c"
		}
#line 434 "Spawn.vala"
		_g_free0 (buffer);
#line 434 "Spawn.vala"
		break;
#line 1651 "Spawn.vala.c"
	}
#line 438 "Spawn.vala"
	result = FALSE;
#line 438 "Spawn.vala"
	return result;
#line 1657 "Spawn.vala.c"
}

static void
g_cclosure_user_marshal_STRING__VOID (GClosure * closure,
                                      GValue * return_value,
                                      guint n_param_values,
                                      const GValue * param_values,
                                      gpointer invocation_hint,
                                      gpointer marshal_data)
{
	typedef const char* (*GMarshalFunc_STRING__VOID) (gpointer data1, gpointer data2);
	register GMarshalFunc_STRING__VOID callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	const char* v_return;
	cc = (GCClosure *) closure;
#line 47 "Spawn.vala"
	g_return_if_fail (return_value != NULL);
#line 47 "Spawn.vala"
	g_return_if_fail (n_param_values == 1);
#line 47 "Spawn.vala"
	if (G_CCLOSURE_SWAP_DATA (closure)) {
#line 47 "Spawn.vala"
		data1 = closure->data;
#line 47 "Spawn.vala"
		data2 = param_values->data[0].v_pointer;
#line 1685 "Spawn.vala.c"
	} else {
#line 47 "Spawn.vala"
		data1 = param_values->data[0].v_pointer;
#line 47 "Spawn.vala"
		data2 = closure->data;
#line 1691 "Spawn.vala.c"
	}
#line 47 "Spawn.vala"
	callback = (GMarshalFunc_STRING__VOID) (marshal_data ? marshal_data : cc->callback);
#line 47 "Spawn.vala"
	v_return = callback (data1, data2);
#line 47 "Spawn.vala"
	g_value_take_string (return_value, v_return);
#line 1699 "Spawn.vala.c"
}

static void
g_cclosure_user_marshal_VOID__INT_STRING_STRING (GClosure * closure,
                                                 GValue * return_value,
                                                 guint n_param_values,
                                                 const GValue * param_values,
                                                 gpointer invocation_hint,
                                                 gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__INT_STRING_STRING) (gpointer data1, gint arg_1, const char* arg_2, const char* arg_3, gpointer data2);
	register GMarshalFunc_VOID__INT_STRING_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
#line 47 "Spawn.vala"
	g_return_if_fail (n_param_values == 4);
#line 47 "Spawn.vala"
	if (G_CCLOSURE_SWAP_DATA (closure)) {
#line 47 "Spawn.vala"
		data1 = closure->data;
#line 47 "Spawn.vala"
		data2 = param_values->data[0].v_pointer;
#line 1724 "Spawn.vala.c"
	} else {
#line 47 "Spawn.vala"
		data1 = param_values->data[0].v_pointer;
#line 47 "Spawn.vala"
		data2 = closure->data;
#line 1730 "Spawn.vala.c"
	}
#line 47 "Spawn.vala"
	callback = (GMarshalFunc_VOID__INT_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
#line 47 "Spawn.vala"
	callback (data1, g_value_get_int (param_values + 1), g_value_get_string (param_values + 2), g_value_get_string (param_values + 3), data2);
#line 1736 "Spawn.vala.c"
}

static void
spawn_class_init (SpawnClass * klass,
                  gpointer klass_data)
{
#line 47 "Spawn.vala"
	spawn_parent_class = g_type_class_peek_parent (klass);
#line 47 "Spawn.vala"
	g_type_class_adjust_private_offset (klass, &Spawn_private_offset);
#line 47 "Spawn.vala"
	G_OBJECT_CLASS (klass)->finalize = spawn_finalize;
#line 1749 "Spawn.vala.c"
	/**
	 * @signal input called at start to send input when process starts?
	 * @return the string or null 
	 */
#line 47 "Spawn.vala"
	spawn_signals[SPAWN_INPUT_SIGNAL] = g_signal_new ("input", TYPE_SPAWN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_STRING__VOID, G_TYPE_STRING, 0);
#line 1756 "Spawn.vala.c"
	/**
	 * @signal complete called at when the command has completed.
	 * 
	 */
#line 47 "Spawn.vala"
	spawn_signals[SPAWN_COMPLETE_SIGNAL] = g_signal_new ("complete", TYPE_SPAWN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_STRING_STRING, G_TYPE_NONE, 3, G_TYPE_INT, G_TYPE_STRING, G_TYPE_STRING);
#line 1763 "Spawn.vala.c"
	/**
	 * @signal output_line called when a line is recieved from the process.
	 * Note you may want to connect this and run 
	 *   if ( Gtk.events_pending()) { Gtk.main_iteration(); }
	 * 
	 * @param {string} str 
	 */
#line 47 "Spawn.vala"
	spawn_signals[SPAWN_OUTPUT_LINE_SIGNAL] = g_signal_new ("output-line", TYPE_SPAWN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
#line 1773 "Spawn.vala.c"
}

static void
spawn_instance_init (Spawn * self,
                     gpointer klass)
{
#line 47 "Spawn.vala"
	self->priv = spawn_get_instance_private (self);
#line 72 "Spawn.vala"
	self->is_async = TRUE;
#line 73 "Spawn.vala"
	self->throw_exceptions = FALSE;
#line 74 "Spawn.vala"
	self->detach = FALSE;
#line 96 "Spawn.vala"
	self->priv->ctx = NULL;
#line 109 "Spawn.vala"
	self->result = 0;
#line 113 "Spawn.vala"
	self->priv->pid = -1;
#line 117 "Spawn.vala"
	self->priv->in_ch = NULL;
#line 121 "Spawn.vala"
	self->priv->out_ch = NULL;
#line 125 "Spawn.vala"
	self->priv->err_ch = NULL;
#line 130 "Spawn.vala"
	self->priv->err_src = -1;
#line 134 "Spawn.vala"
	self->priv->out_src = -1;
#line 1804 "Spawn.vala.c"
}

static void
spawn_finalize (GObject * obj)
{
	Spawn * self;
#line 47 "Spawn.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SPAWN, Spawn);
#line 68 "Spawn.vala"
	_g_free0 (self->cwd);
#line 69 "Spawn.vala"
	self->args = (_vala_array_free (self->args, self->args_length1, (GDestroyNotify) g_free), NULL);
#line 70 "Spawn.vala"
	self->env = (_vala_array_free (self->env, self->env_length1, (GDestroyNotify) g_free), NULL);
#line 96 "Spawn.vala"
	_g_main_loop_unref0 (self->priv->ctx);
#line 101 "Spawn.vala"
	_g_free0 (self->output);
#line 105 "Spawn.vala"
	_g_free0 (self->stderr);
#line 117 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->in_ch);
#line 121 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->out_ch);
#line 125 "Spawn.vala"
	_g_io_channel_unref0 (self->priv->err_ch);
#line 47 "Spawn.vala"
	G_OBJECT_CLASS (spawn_parent_class)->finalize (obj);
#line 1833 "Spawn.vala.c"
}

/**
 * @class Spawn
 * @param cwd {String}            working directory. (defaults to home directory)
 * @param args {Array}            arguments eg. [ 'ls', '-l' ]
 * 
 
 * @arg env {Array}             enviroment eg. [ 'GITDIR=/home/test' ]
 * @arg is_async {Boolean} (optional)return instantly, or wait for exit. (default no)
 * @arg trhow_exceptions {Boolean}    throw exception on failure (default no)
 
 * 
 */
static GType
spawn_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (SpawnClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) spawn_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Spawn), 0, (GInstanceInitFunc) spawn_instance_init, NULL };
	GType spawn_type_id;
	spawn_type_id = g_type_register_static (G_TYPE_OBJECT, "Spawn", &g_define_type_info, 0);
	Spawn_private_offset = g_type_add_instance_private (spawn_type_id, sizeof (SpawnPrivate));
	return spawn_type_id;
}

GType
spawn_get_type (void)
{
	static volatile gsize spawn_type_id__once = 0;
	if (g_once_init_enter (&spawn_type_id__once)) {
		GType spawn_type_id;
		spawn_type_id = spawn_get_type_once ();
		g_once_init_leave (&spawn_type_id__once, spawn_type_id);
	}
	return spawn_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static inline gpointer
_vala_memdup2 (gconstpointer mem,
               gsize byte_size)
{
	gpointer new_mem;
	if (mem && byte_size != 0) {
		new_mem = g_malloc (byte_size);
		memcpy (new_mem, mem, byte_size);
	} else {
		new_mem = NULL;
	}
	return new_mem;
}

